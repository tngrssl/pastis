

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mrs.sim &mdash; PASTIS  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> PASTIS
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../mrs.html">mrs package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PASTIS</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>mrs.sim</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mrs.sim</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Three classes&#39; definition in here.</span>

<span class="sd">    * a params class which stores and manipulate the parameters of our MRS fitting/simulation model</span>
<span class="sd">    * a metabolite class which stores and can compute a MRS modeled signal for a single metabolite, based on the pyGAMMA library (for python 3!) using a specific MR sequence described by pulse flip angles and delays</span>
<span class="sd">    * a metabolite_group class which contains several metabolites</span>
<span class="sd">    * a metabolite_basis_set class which contains a whole database of metabolites chemical shifts, J-couplings, nucleis and computed signals. Usefull to simulate all kind of MRS data for various metabolites, concentrations acquired with various sequences...</span>

<span class="sd">@author: Tangi Roussel</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">suspect</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span> <span class="k">as</span> <span class="nn">ma</span>
<span class="kn">import</span> <span class="nn">matplotlib.pylab</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">display</span>
<span class="kn">from</span> <span class="nn">xlrd</span> <span class="kn">import</span> <span class="n">open_workbook</span>
<span class="kn">from</span> <span class="nn">termcolor</span> <span class="kn">import</span> <span class="n">cprint</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">from</span> <span class="nn">mrs</span> <span class="kn">import</span> <span class="n">reco</span>
<span class="kn">from</span> <span class="nn">mrs</span> <span class="kn">import</span> <span class="n">aliases</span> <span class="k">as</span> <span class="n">xxx</span>
<span class="kn">from</span> <span class="nn">mrs</span> <span class="kn">import</span> <span class="n">log</span>
<span class="kn">from</span> <span class="nn">mrs</span> <span class="kn">import</span> <span class="n">paths</span> <span class="k">as</span> <span class="n">default_paths</span>
<span class="kn">import</span> <span class="nn">copy</span> <span class="k">as</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">pdb</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pygamma</span> <span class="k">as</span> <span class="nn">pg</span>
    <span class="n">GAMMA_LIB_LOADED</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">GAMMA_LIB_LOADED</span> <span class="o">=</span> <span class="kc">False</span>

<span class="c1"># GAMMA_LIB_LOADED forced to False for debug</span>
<span class="c1"># GAMMA_LIB_LOADED = False</span>


<div class="viewcode-block" id="sequence_exc_type"><a class="viewcode-back" href="../../mrs.html#mrs.sim.sequence_exc_type">[docs]</a><span class="k">class</span> <span class="nc">sequence_exc_type</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The enum sequence_exc_type describes the type of excitation scheme of the sequence. Can be usefull when comparing sequences.&quot;&quot;&quot;</span>

    <span class="n">PULSE_ACQUIRE</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">STIMULATED_ECHO</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">SPIN_ECHO</span> <span class="o">=</span> <span class="mi">3</span></div>


<div class="viewcode-block" id="gating_signal_source"><a class="viewcode-back" href="../../mrs.html#mrs.sim.gating_signal_source">[docs]</a><span class="k">class</span> <span class="nc">gating_signal_source</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The enum gating_signal_source describes the type of gating used during the acquisition.&quot;&quot;&quot;</span>

    <span class="n">NO_GATING</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">CARDIAC_ECG</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">CARDIAC_GATING</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">RESP_GATING</span> <span class="o">=</span> <span class="mi">16</span></div>


<div class="viewcode-block" id="params"><a class="viewcode-back" href="../../mrs.html#mrs.sim.params">[docs]</a><span class="k">class</span> <span class="nc">params</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that stores the parameters used to modelize a MR spectrum during simulation or fit.&quot;&quot;&quot;</span>

    <span class="c1"># frozen stuff: a technique to prevent creating new attributes</span>
    <span class="c1"># (https://stackoverflow.com/questions/3603502/prevent-creating-new-attributes-outside-init)</span>
    <span class="n">__isfrozen</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overload of __setattr__ method to check that we are not creating a new attribute.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__isfrozen</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error_new_attribute</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meta_bs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a params object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        meta_bs: metabolite_basis_set</span>
<span class="sd">            A metabolite_basis_set object to which this params object is linked to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># those parameters are related to a metabolite database</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_bs</span> <span class="o">=</span> <span class="n">meta_bs</span>
        <span class="c1"># the link-lock vector used to control the model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_linklock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># the error vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># the corr vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_corr_mat</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># freeze</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__isfrozen</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">meta_bs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a params object that inherits of numpy array&#39;s class. This class is used to deal with metabolite parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        meta_bs: metabolite_basis_set</span>
<span class="sd">            A metabolite_basis_set object to which this params object is linked to</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj : params numpy array [n,4]</span>
<span class="sd">            Resulting constructed params object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">meta_bs</span><span class="p">),</span> <span class="mi">4</span><span class="p">])</span>
        <span class="n">obj</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">return</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overload of special numpy array method called when playing around with stuff relative to object copy etc...</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obj : params numpy array [n,4]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># to begin, I followed online help and wrote:</span>
        <span class="c1"># self._meta_bs = getattr(obj, &#39;meta_bs&#39;, None)</span>
        <span class="c1"># self._linklock = getattr(obj, &#39;linklock&#39;, None)</span>
        <span class="c1"># self._errors = getattr(obj, &#39;errors&#39;, None)</span>
        <span class="c1"># self._corr_mat = getattr(obj, &#39;corr_mat&#39;, None)</span>

        <span class="c1"># but that only works for some simple attribute types</span>
        <span class="c1"># if the attributes are nd arrays, only the pointers will be copied...</span>
        <span class="c1"># leading to terrible bugs</span>

        <span class="c1"># for now, I could only find this ugly way:</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_bs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;meta_bs&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_bs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meta_bs</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">meta_bs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_linklock</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;linklock&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">linklock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_linklock</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">linklock</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;errors&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_corr_mat</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;corr_mat&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_mat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_corr_mat</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">corr_mat</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">meta_bs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Property method for meta_bs.&quot;&quot;&quot;</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meta_bs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">linklock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Property method for linklock.&quot;&quot;&quot;</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_linklock</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Property method for errors.&quot;&quot;&quot;</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">corr_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Property method for corr_mat.&quot;&quot;&quot;</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_corr_mat</span><span class="p">)</span>

<div class="viewcode-block" id="params.get_meta_names"><a class="viewcode-back" href="../../mrs.html#mrs.sim.params.get_meta_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_meta_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">LCModel_names</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return list of metabolite names controlled by this params object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list(self._meta_bs.keys()) : list</span>
<span class="sd">            List of metabolite names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">LCModel_names</span><span class="p">):</span>
            <span class="n">meta_names_lcmodel_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">this_metagroup_key</span><span class="p">,</span> <span class="n">this_metagroup_entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meta_bs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">meta_names_lcmodel_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_metagroup_entry</span><span class="p">[</span><span class="s2">&quot;LCModel&quot;</span><span class="p">])</span>

            <span class="k">return</span><span class="p">(</span><span class="n">meta_names_lcmodel_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meta_bs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span></div>

<div class="viewcode-block" id="params.get_errors_prct"><a class="viewcode-back" href="../../mrs.html#mrs.sim.params.get_errors_prct">[docs]</a>    <span class="k">def</span> <span class="nf">get_errors_prct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return relative errors in percentage.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        errors_prct : numpy array</span>
<span class="sd">            Errors in percentage (%)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># calculate percentages</span>
        <span class="n">errors_prct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">/</span> <span class="bp">self</span><span class="p">[:]</span> <span class="o">*</span> <span class="mf">100.0</span>

        <span class="k">return</span><span class="p">(</span><span class="n">errors_prct</span><span class="p">)</span></div>

<div class="viewcode-block" id="params.check"><a class="viewcode-back" href="../../mrs.html#mrs.sim.params.check">[docs]</a>    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the linklock vector is consistent and read to be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        all_right : boolean</span>
<span class="sd">            True if eveything is ok, False if linklock vector if broken</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># by default, eveything is ok</span>
        <span class="n">all_right</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">LL_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">linklock</span><span class="p">)</span>
        <span class="n">LL_list</span> <span class="o">=</span> <span class="n">LL_list</span><span class="p">[</span><span class="n">LL_list</span> <span class="o">&gt;=</span> <span class="o">+</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">this_LL</span> <span class="ow">in</span> <span class="n">LL_list</span><span class="p">:</span>
            <span class="c1"># count number of master</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">linklock</span> <span class="o">==</span> <span class="o">-</span><span class="n">this_LL</span><span class="p">)</span>
            <span class="n">n_masters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:])</span>

            <span class="c1"># count number of slaves</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">linklock</span> <span class="o">==</span> <span class="o">+</span><span class="n">this_LL</span><span class="p">)</span>
            <span class="n">n_slaves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:])</span>

            <span class="c1"># master ratio values should be all equal to one</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">linklock</span> <span class="o">==</span> <span class="o">-</span><span class="n">this_LL</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:])</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">):</span>
                <span class="n">all_right</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># now, we should have one single master</span>
            <span class="k">if</span><span class="p">(</span><span class="n">n_masters</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">all_right</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># and several slaves</span>
            <span class="k">if</span><span class="p">(</span><span class="n">n_slaves</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">all_right</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span><span class="p">(</span><span class="n">all_right</span><span class="p">)</span></div>

<div class="viewcode-block" id="params.toFreeParams"><a class="viewcode-back" href="../../mrs.html#mrs.sim.params.toFreeParams">[docs]</a>    <span class="k">def</span> <span class="nf">toFreeParams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return free parameters, in other words, parameters for which LL=0 (free) or LL&lt;0 (free and master).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self[self.linklock&lt;=0] : 1D numpy array of free parameters</span>
<span class="sd">            Array of free parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">linklock</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="params.toFullParams"><a class="viewcode-back" href="../../mrs.html#mrs.sim.params.toFullParams">[docs]</a>    <span class="k">def</span> <span class="nf">toFullParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pFree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert an array of free paramters to a full array of parameters based on the link-lock array and the initial parameter values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pFree : 1D numpy array of free parameters</span>
<span class="sd">            Array of free parameters</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.copy() : params object</span>
<span class="sd">            Copy of this current object with the applied modification</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># init: we are working on a copy</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># link-lock stuff</span>
        <span class="n">p</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">linklock</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pFree</span>

        <span class="c1"># some of them are masters, copying values to slaves</span>
        <span class="c1"># find unique LL values</span>
        <span class="n">LL_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">linklock</span><span class="p">)</span>
        <span class="n">LL_list</span> <span class="o">=</span> <span class="n">LL_list</span><span class="p">[</span><span class="n">LL_list</span> <span class="o">&gt;=</span> <span class="o">+</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">this_LL</span> <span class="ow">in</span> <span class="n">LL_list</span><span class="p">:</span>
            <span class="n">p</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">linklock</span> <span class="o">==</span> <span class="o">+</span><span class="n">this_LL</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">linklock</span> <span class="o">==</span> <span class="o">-</span><span class="n">this_LL</span><span class="p">]</span>

        <span class="k">return</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></div>

<div class="viewcode-block" id="params.set_T2_weighting"><a class="viewcode-back" href="../../mrs.html#mrs.sim.params.set_T2_weighting">[docs]</a>    <span class="k">def</span> <span class="nf">set_T2_weighting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">te</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recalculate metabolite amplitude parameters by applying a T2 relaxation, usefull for simulations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        te : float</span>
<span class="sd">            Echo time in (ms)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.copy() : params object</span>
<span class="sd">            Full array of parameters corrected in T2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># init: we are working on a copy</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># browse though the database and find T2s</span>
        <span class="n">params_T2s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">this_metagroup_key</span><span class="p">,</span> <span class="n">this_metagroup_entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meta_bs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">params_T2s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_metagroup_entry</span><span class="p">[</span><span class="s2">&quot;T2&quot;</span><span class="p">])</span>

        <span class="c1"># convert to np</span>
        <span class="n">params_T2s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params_T2s</span><span class="p">)</span>

        <span class="c1"># apply T2w for given TE</span>
        <span class="n">multiplication_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">te</span> <span class="o">/</span> <span class="n">params_T2s</span><span class="p">)</span>
        <span class="n">p</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">*</span> <span class="n">multiplication_factor</span>
        <span class="c1"># to errors too</span>
        <span class="n">p</span><span class="o">.</span><span class="n">errors</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">errors</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">*</span> <span class="n">multiplication_factor</span>
        <span class="k">return</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></div>

<div class="viewcode-block" id="params.correct_T2s"><a class="viewcode-back" href="../../mrs.html#mrs.sim.params.correct_T2s">[docs]</a>    <span class="k">def</span> <span class="nf">correct_T2s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">te</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Correct the concentration values of a parameter array depending on the TE and the common values of T2s for each metabolite.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        te : float</span>
<span class="sd">            Echo time in (ms)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.copy() : params object</span>
<span class="sd">            Full array of parameters corrected in T2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># init: we are working on a copy</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># browse though the database and find T2s</span>
        <span class="n">params_T2s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">this_metagroup_key</span><span class="p">,</span> <span class="n">this_metagroup_entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meta_bs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">params_T2s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_metagroup_entry</span><span class="p">[</span><span class="s2">&quot;T2&quot;</span><span class="p">])</span>

        <span class="c1"># convert to np</span>
        <span class="n">params_T2s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params_T2s</span><span class="p">)</span>

        <span class="c1"># finding real concentration values at TE=0ms</span>
        <span class="n">multiplication_factor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">te</span> <span class="o">/</span> <span class="n">params_T2s</span><span class="p">)</span>
        <span class="n">p</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">*</span> <span class="n">multiplication_factor</span>
        <span class="c1"># to errors too</span>
        <span class="n">p</span><span class="o">.</span><span class="n">errors</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">errors</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">*</span> <span class="n">multiplication_factor</span>
        <span class="k">return</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></div>

<div class="viewcode-block" id="params.correct_T1s"><a class="viewcode-back" href="../../mrs.html#mrs.sim.params.correct_T1s">[docs]</a>    <span class="k">def</span> <span class="nf">correct_T1s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Correct the concentration values of a parameter array depending on the TR and the common values of T1s for each metabolite.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tr : float</span>
<span class="sd">            Repetition time in (ms)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.copy() : params object</span>
<span class="sd">            Full array of parameters corrected in T1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># init: we are working on a copy</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># browse though the database and find T1s</span>
        <span class="n">params_T1s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">this_metagroup_key</span><span class="p">,</span> <span class="n">this_metagroup_entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meta_bs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">params_T1s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_metagroup_entry</span><span class="p">[</span><span class="s2">&quot;T1&quot;</span><span class="p">])</span>

        <span class="c1"># convert to np</span>
        <span class="n">params_T1s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params_T1s</span><span class="p">)</span>

        <span class="c1"># finding real concentration values at TE=0ms</span>
        <span class="n">multiplication_factor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">tr</span> <span class="o">/</span> <span class="n">params_T1s</span><span class="p">))</span>
        <span class="n">p</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">*</span> <span class="n">multiplication_factor</span>
        <span class="c1"># to errors too</span>
        <span class="n">p</span><span class="o">.</span><span class="n">errors</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">errors</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">*</span> <span class="n">multiplication_factor</span>
        <span class="k">return</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></div>

<div class="viewcode-block" id="params.get_absolutes"><a class="viewcode-back" href="../../mrs.html#mrs.sim.params.get_absolutes">[docs]</a>    <span class="k">def</span> <span class="nf">get_absolutes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mIndex</span><span class="o">=</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_Water</span><span class="p">,</span> <span class="n">m_concentration_mmolkg</span><span class="o">=</span><span class="mf">55000.0</span><span class="p">,</span> <span class="n">params_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the metabolic concentration values relative to a metabolite. The metabolite relative concentration can be taken from the current params vector or another params vector (params_ref), assuming the absolute metabolite concentration value. Usefull to get concentrations relative to water (called absolute concentrations).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mIndex : int</span>
<span class="sd">            Index of metabolite of reference</span>
<span class="sd">        water_concentration : float</span>
<span class="sd">            Assumed water concentration used to calculate absolute concentration estimates (mmol/kg)</span>
<span class="sd">        params_ref : params object</span>
<span class="sd">            Array of parameters used to get the concentration estimate of the reference metabolite</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.copy() : params object</span>
<span class="sd">            Full array of parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># init: check ref params</span>
        <span class="k">if</span><span class="p">(</span><span class="n">params_ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">params_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># init: we are working on copies</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># do the maths</span>
        <span class="n">multiplication_factor</span> <span class="o">=</span> <span class="n">m_concentration_mmolkg</span> <span class="o">/</span> <span class="n">params_ref</span><span class="p">[</span><span class="n">mIndex</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span>
        <span class="n">p2</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">*</span> <span class="n">multiplication_factor</span>

        <span class="c1"># deal with errors too</span>
        <span class="c1"># see paper http://dx.doi.org/10.1007/s10334-005-0018-7</span>
        <span class="c1"># inspired from ratio, considering zero correlation between metabolite of interest and ref:</span>
        <span class="c1"># relCRB(1/ref) = sqrt(relCRB1^2 + relCRB2^2)</span>
        <span class="c1"># get numerator rel CRBs for cm</span>
        <span class="n">relCRBs_num</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">get_errors_prct</span><span class="p">()[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span>
        <span class="c1"># get denominator rel CRBs for cm</span>
        <span class="n">relCRBs_den</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="n">get_errors_prct</span><span class="p">()[</span><span class="n">mIndex</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span>
        <span class="c1"># calculate the final relCRB</span>
        <span class="n">rel_CRBs_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">relCRBs_num</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">relCRBs_den</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># back to absCRB</span>
        <span class="n">abs_CRBs_ratio</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">*</span> <span class="n">rel_CRBs_ratio</span> <span class="o">/</span> <span class="mf">100.0</span>

        <span class="n">p2</span><span class="o">.</span><span class="n">_errors</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_CRBs_ratio</span>
        <span class="k">return</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span></div>

<div class="viewcode-block" id="params.get_ratios"><a class="viewcode-back" href="../../mrs.html#mrs.sim.params.get_ratios">[docs]</a>    <span class="k">def</span> <span class="nf">get_ratios</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mIndex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the metabolite ratios.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mIndex : int</span>
<span class="sd">            Index of metabolite of reference used as the denominator</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.copy() : params object</span>
<span class="sd">            Full array of parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># init: we are working on a copy</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># ratio</span>
        <span class="n">p2</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">/</span> <span class="n">p1</span><span class="p">[</span><span class="n">mIndex</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span>

        <span class="c1"># deal with errors too</span>
        <span class="c1"># if correlation matrix available</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_mat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># see paper http://dx.doi.org/10.1007/s10334-005-0018-7</span>
            <span class="c1"># relCRB(1/2) = sqrt(relCRB1^2 + relCRB2^2 - 2*corr1_2*relCRB1*relCRB2)</span>
            <span class="c1"># get numerator rel CRBs for cm</span>
            <span class="n">relCRBs_num</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">get_errors_prct</span><span class="p">()[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span>
            <span class="c1"># get denominator rel CRBs for cm</span>
            <span class="n">relCRBs_den</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">get_errors_prct</span><span class="p">()[</span><span class="n">mIndex</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span>

            <span class="c1"># get corr coeff between num and den cm</span>
            <span class="c1"># first, get free param corr mat</span>
            <span class="n">free_param_corr_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_mat</span>
            <span class="c1"># convert mIndex to free params index</span>
            <span class="n">p3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># replace cm by index</span>
            <span class="n">p3</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p3</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># lock all other pars</span>
            <span class="n">p3</span><span class="o">.</span><span class="n">linklock</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_dd</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">p3</span><span class="o">.</span><span class="n">linklock</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_df</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">p3</span><span class="o">.</span><span class="n">linklock</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_dp</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1"># convert to free params</span>
            <span class="n">p3_free</span> <span class="o">=</span> <span class="n">p3</span><span class="o">.</span><span class="n">toFreeParams</span><span class="p">()</span>
            <span class="c1"># here we should get a list of indexes</span>
            <span class="c1"># find where is mIndex and we did it</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">p3_free</span> <span class="o">==</span> <span class="n">mIndex</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">ind_free_pars_mIndex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">p3_free</span> <span class="o">==</span> <span class="n">mIndex</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># extract corr vector</span>
                <span class="n">free_param_corr_vec</span> <span class="o">=</span> <span class="n">free_param_corr_mat</span><span class="p">[:,</span> <span class="n">ind_free_pars_mIndex</span><span class="p">]</span>
                <span class="c1"># convert it to full params</span>
                <span class="n">p3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># lock all other pars</span>
                <span class="n">p3</span><span class="o">.</span><span class="n">linklock</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_dd</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">p3</span><span class="o">.</span><span class="n">linklock</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_df</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">p3</span><span class="o">.</span><span class="n">linklock</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_dp</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1"># replace cm by cor coeffs</span>
                <span class="n">p3</span> <span class="o">=</span> <span class="n">p3</span><span class="o">.</span><span class="n">toFullParams</span><span class="p">(</span><span class="n">free_param_corr_vec</span><span class="p">)</span>
                <span class="c1"># get full param corr vector</span>
                <span class="n">full_param_corr_vec</span> <span class="o">=</span> <span class="n">p3</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span>
                <span class="c1"># make it absolute</span>
                <span class="n">rc_num_den_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">full_param_corr_vec</span><span class="p">)</span>

                <span class="c1"># calculate the final relCRB</span>
                <span class="n">rel_CRBs_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">relCRBs_num</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">relCRBs_den</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rc_num_den_abs</span> <span class="o">*</span> <span class="n">relCRBs_num</span> <span class="o">*</span> <span class="n">relCRBs_den</span><span class="p">)</span>
                <span class="c1"># back to absCRB</span>
                <span class="n">abs_CRBs_ratio</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">*</span> <span class="n">rel_CRBs_ratio</span> <span class="o">/</span> <span class="mf">100.0</span>
                <span class="n">p2</span><span class="o">.</span><span class="n">_errors</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_CRBs_ratio</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if we fall here, it probably means that the fit that generated thsi param object was done without this metabolite. Therefore, no correlation coefficient available. So we switch to an approximate ratio error calculation: we take the error of the numerator only (which is actually what a lot of people do)...</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;no correlation coefficient available for metabolite [</span><span class="si">%d</span><span class="s2">]: cannot calculate the ratio error properly... Taking the numerator error instead. :(&quot;</span> <span class="o">%</span> <span class="n">mIndex</span><span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span></div>

<div class="viewcode-block" id="params.set_default_min"><a class="viewcode-back" href="../../mrs.html#mrs.sim.params.set_default_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_default_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the params object to the default minimum values, no macromolecules.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.copy() : params object</span>
<span class="sd">            Copy of this current object with the applied modification</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># all to zero</span>
        <span class="bp">self</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1"># metabolites min values</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MBs</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MBs</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_dd</span><span class="p">]</span> <span class="o">=</span> <span class="mf">5.0</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MBs</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_df</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">10.0</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MBs</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_dp</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.1</span>

        <span class="c1"># link all to the NAA singlet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linklock</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">(</span><span class="n">xxx</span><span class="o">.</span><span class="n">n_All</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linklock</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_Ref_MB</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linklock</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_Water</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># no MMs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linklock</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MMs</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="params.set_default_max"><a class="viewcode-back" href="../../mrs.html#mrs.sim.params.set_default_max">[docs]</a>    <span class="k">def</span> <span class="nf">set_default_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the params object to the default maximum values, no macromolecules.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.copy() : params object</span>
<span class="sd">            Copy of this current object with the applied modification</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># all to zero</span>
        <span class="bp">self</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1"># metabolites min values</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MBs</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">=</span> <span class="mf">50.0</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MBs</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_dd</span><span class="p">]</span> <span class="o">=</span> <span class="mf">100.0</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MBs</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_df</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="mf">10.0</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MBs</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_dp</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="mf">0.1</span>

        <span class="c1"># link all to the NAA singlet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linklock</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">(</span><span class="n">xxx</span><span class="o">.</span><span class="n">n_All</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linklock</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_Ref_MB</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linklock</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_Water</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># no MMs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linklock</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MMs</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="params.set_default_water_min"><a class="viewcode-back" href="../../mrs.html#mrs.sim.params.set_default_water_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_default_water_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the params object to the default minimum values for a water only fit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.copy() : params object</span>
<span class="sd">            Copy of this current object with the applied modification</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_default_min</span><span class="p">()</span>
        <span class="c1"># all concentrations to zero</span>
        <span class="bp">self</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># water min values</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MBs</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_df</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">20.0</span>

        <span class="c1"># lock everything except water</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linklock</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linklock</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_Water</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="params.set_default_water_max"><a class="viewcode-back" href="../../mrs.html#mrs.sim.params.set_default_water_max">[docs]</a>    <span class="k">def</span> <span class="nf">set_default_water_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the params object to the default maximum values for a water only fit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.copy() : params object</span>
<span class="sd">            Copy of this current object with the applied modification</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_default_max</span><span class="p">()</span>
        <span class="c1"># all concentrations to zero</span>
        <span class="bp">self</span><span class="p">[:,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># water max values</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MBs</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_df</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="mf">20.0</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_Water</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">100000.0</span>

        <span class="c1"># lock everything except water</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linklock</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linklock</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_Water</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="params.add_macromolecules_min"><a class="viewcode-back" href="../../mrs.html#mrs.sim.params.add_macromolecules_min">[docs]</a>    <span class="k">def</span> <span class="nf">add_macromolecules_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enable the macromolecules modelization, minimum values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.copy() : params object</span>
<span class="sd">            Copy of this current object with the applied modification</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># macromolecules minimum values</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MMs</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.001</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MMs</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_dd</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MMs</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_df</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MMs</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_dp</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.1</span>

        <span class="c1"># link all MM parameters to MM1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linklock</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MMs</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">3000</span><span class="p">,</span> <span class="mi">4000</span><span class="p">],</span> <span class="p">(</span><span class="n">xxx</span><span class="o">.</span><span class="n">n_MMs</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linklock</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_Ref_MM</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2000</span><span class="p">,</span> <span class="o">-</span><span class="mi">3000</span><span class="p">,</span> <span class="o">-</span><span class="mi">4000</span><span class="p">]</span>

        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="params.add_macromolecules_max"><a class="viewcode-back" href="../../mrs.html#mrs.sim.params.add_macromolecules_max">[docs]</a>    <span class="k">def</span> <span class="nf">add_macromolecules_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enable the macromolecules modelization, maximum values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.copy() : params object</span>
<span class="sd">            Copy of this current object with the applied modification</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MMs</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_cm</span><span class="p">]</span> <span class="o">=</span> <span class="mf">100.0</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MMs</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_dd</span><span class="p">]</span> <span class="o">=</span> <span class="mf">200.0</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MMs</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_df</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="mi">5</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MMs</span><span class="p">,</span> <span class="n">xxx</span><span class="o">.</span><span class="n">p_dp</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="mf">0.1</span>

        <span class="c1"># link all MM parameters to MM1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linklock</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_All_MMs</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">3000</span><span class="p">,</span> <span class="mi">4000</span><span class="p">],</span> <span class="p">(</span><span class="n">xxx</span><span class="o">.</span><span class="n">n_MMs</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linklock</span><span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_Ref_MM</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2000</span><span class="p">,</span> <span class="o">-</span><span class="mi">3000</span><span class="p">,</span> <span class="o">-</span><span class="mi">4000</span><span class="p">]</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="params.print"><a class="viewcode-back" href="../../mrs.html#mrs.sim.params.print">[docs]</a>    <span class="k">def</span> <span class="nf">print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bMM</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bLL</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display an array of parameters in the console.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bMM : boolean</span>
<span class="sd">            Includes macromolecular parameters (True) or not (False)</span>
<span class="sd">        bLL : boolean</span>
<span class="sd">            Displays link-lock status for each parameter (True) or not (False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cell_nchar</span> <span class="o">=</span> <span class="mi">11</span>

        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;displaying parameters...&quot;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info_line________________________</span><span class="p">()</span>
        <span class="k">if</span><span class="p">(</span><span class="n">bMM</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">xxx</span><span class="o">.</span><span class="n">n_All</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">xxx</span><span class="o">.</span><span class="n">n_MBs</span>

        <span class="n">meta_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta_names</span><span class="p">()</span>
        <span class="n">LLtransTab</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">maketrans</span><span class="p">(</span><span class="s2">&quot;-+0123456789&quot;</span><span class="p">,</span> <span class="s2">&quot;⁻⁺⁰¹²³⁴⁵⁶⁷⁸⁹&quot;</span><span class="p">)</span>
        <span class="n">LLcolors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="s1">&#39;grey&#39;</span><span class="p">,</span> <span class="s1">&#39;yellow&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;magenta&#39;</span><span class="p">,</span> <span class="s1">&#39;cyan&#39;</span><span class="p">,</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="s1">&#39;grey&#39;</span><span class="p">,</span> <span class="s1">&#39;yellow&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;magenta&#39;</span><span class="p">,</span> <span class="s1">&#39;cyan&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[#] &quot;</span> <span class="o">+</span> <span class="s2">&quot;Metabolite&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">cell_nchar</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;[cm]&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">cell_nchar</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;[dd]&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">cell_nchar</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;[df]&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">cell_nchar</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;[dp]&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">cell_nchar</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;#</span><span class="si">%2d</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">meta_names</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">cell_nchar</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">kp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="k">if</span><span class="p">(</span><span class="n">bLL</span><span class="p">):</span>
                    <span class="n">thisLL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linklock</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">kp</span><span class="p">]</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">thisLL</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="n">thisLL_str</span> <span class="o">=</span> <span class="s2">&quot;+</span><span class="si">%1.0f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">thisLL</span>
                    <span class="k">elif</span><span class="p">(</span><span class="n">thisLL</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="n">thisLL_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%1.0f</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="n">thisLL</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">thisLL_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%1.0f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">thisLL</span>

                    <span class="n">thisLL_str</span> <span class="o">=</span> <span class="n">thisLL_str</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">LLtransTab</span><span class="p">)</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">thisLL</span> <span class="o">==</span> <span class="o">+</span><span class="mf">1.0</span><span class="p">):</span>
                        <span class="n">thisLL_color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ind_color</span> <span class="o">=</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">thisLL</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">LLcolors</span><span class="p">)))</span>
                        <span class="n">thisLL_color</span> <span class="o">=</span> <span class="n">LLcolors</span><span class="p">[</span><span class="n">ind_color</span><span class="p">]</span>

                    <span class="n">this_cell_str</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;(</span><span class="si">%4.1f</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">kp</span><span class="p">])</span> <span class="o">+</span> <span class="n">thisLL_str</span>
                    <span class="n">cprint</span><span class="p">(</span><span class="n">this_cell_str</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">cell_nchar</span><span class="p">),</span> <span class="n">thisLL_color</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bold&#39;</span><span class="p">],</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;(</span><span class="si">%4.1f</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">kp</span><span class="p">])</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">cell_nchar</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info_line________________________</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reduce internal pickling method used when dumping. Copied from MRSData2 class. Modified so that params attributes are not forgotten. See for more info: https://docs.python.org/3/library/pickle.html .&quot;&quot;&quot;</span>
        <span class="c1"># get numpy reduce tuple</span>
        <span class="n">rd</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__reduce__</span><span class="p">()</span>
        <span class="c1"># add params attributes</span>
        <span class="n">rd2</span> <span class="o">=</span> <span class="n">rd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">,)</span>
        <span class="c1"># return the new reduce tuple version</span>
        <span class="k">return</span><span class="p">(</span><span class="n">rd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rd2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set new state to object. Internal pickling method used when loading. Copied from MRSData2 class. Modified so that params attributes are not forgotten. See for more info: https://docs.python.org/3/library/pickle.html .&quot;&quot;&quot;</span>
        <span class="c1"># load params attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># load all the rest relative to numpy</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="params.to_dataframe"><a class="viewcode-back" href="../../mrs.html#mrs.sim.params.to_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">to_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix_str</span><span class="o">=</span><span class="s2">&quot;params_&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this params object to dataframe.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        prefix_str : string</span>
<span class="sd">            Prefix string to add to column names</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df : Dataframe</span>
<span class="sd">            Containing this param object as a vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;converting to dataframe...&quot;</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">([</span><span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)])</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">regex</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;^(?!_).*&quot;</span><span class="p">))</span>

        <span class="n">meta_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta_names</span><span class="p">()</span>
        <span class="n">par_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cm&quot;</span><span class="p">,</span> <span class="s2">&quot;dd&quot;</span><span class="p">,</span> <span class="s2">&quot;df&quot;</span><span class="p">,</span> <span class="s2">&quot;dp&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">im</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meta_names</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ip</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">par_names</span><span class="p">):</span>
                <span class="n">df</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="s2">&quot;|&quot;</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="s2">&quot;|val&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">im</span><span class="p">,</span> <span class="n">ip</span><span class="p">]</span>
                <span class="n">df</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="s2">&quot;|&quot;</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="s2">&quot;|err&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="p">[</span><span class="n">im</span><span class="p">,</span> <span class="n">ip</span><span class="p">]</span>

        <span class="c1"># add prefix</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">add_prefix</span><span class="p">(</span><span class="n">prefix_str</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="mrs_sequence"><a class="viewcode-back" href="../../mrs.html#mrs.sim.mrs_sequence">[docs]</a><span class="k">class</span> <span class="nc">mrs_sequence</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A class that stores a sequence and all its parameters used for simulation. This is a generic sequence class that you need to overload. By default, the simulated sequence is a simple pulse-acquire NMR experiment.&quot;&quot;&quot;</span>

    <span class="c1"># frozen stuff: a technique to prevent creating new attributes</span>
    <span class="c1"># (https://stackoverflow.com/questions/3603502/prevent-creating-new-attributes-outside-init)</span>
    <span class="n">__isfrozen</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overload of __setattr__ method to check that we are not creating a new attribute.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__isfrozen</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error_new_attribute</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="o">=</span><span class="mf">3500.0</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">ds</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">nuclei</span><span class="o">=</span><span class="s2">&quot;1H&quot;</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="mi">4096</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">voxel_size</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="mf">5000.0</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="mf">297.2062580</span><span class="p">,</span> <span class="n">vref</span><span class="o">=</span><span class="mf">250.0</span><span class="p">,</span> <span class="n">shims</span><span class="o">=</span><span class="p">[],</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">gating_mode</span><span class="o">=</span><span class="n">gating_signal_source</span><span class="o">.</span><span class="n">NO_GATING</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the sequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        te : float</span>
<span class="sd">            Echo time (ms)</span>
<span class="sd">        tr : float</span>
<span class="sd">            Repetition time (ms)</span>
<span class="sd">        na : int</span>
<span class="sd">            Number of averages/excitations</span>
<span class="sd">        ds : int</span>
<span class="sd">            Number of summy scans</span>
<span class="sd">        nuclei : string</span>
<span class="sd">            Observed nuclei. Examples: &quot;1H&quot;, &quot;31P&quot;, etc.</span>
<span class="sd">        npts : int</span>
<span class="sd">            Number of acquisition points</span>
<span class="sd">        voxel_size : list</span>
<span class="sd">            Dimensions of voxel (mm)</span>
<span class="sd">        fs : float</span>
<span class="sd">            Acquisition bandwidth (Hz)</span>
<span class="sd">        f0 : float</span>
<span class="sd">            Water Larmor frequency (MHz)</span>
<span class="sd">        vref : float</span>
<span class="sd">            Reference voltage (V)</span>
<span class="sd">        shims : list of floats</span>
<span class="sd">            List of shim voltages in volts</span>
<span class="sd">        timestamp : float</span>
<span class="sd">            Timestamp in ms</span>
<span class="sd">        gating_mode : gating_signal_source</span>
<span class="sd">            Acquisition triggering mode</span>
<span class="sd">        eff_acquisition_time : float</span>
<span class="sd">            Effective acquisition time (s)</span>
<span class="sd">        scaling_factor : float</span>
<span class="sd">            Scaling FID intensity factor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># all sequences have those parameters</span>
        <span class="c1"># name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;fid&quot;</span>
        <span class="c1"># type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exc_type</span> <span class="o">=</span> <span class="n">sequence_exc_type</span><span class="o">.</span><span class="n">PULSE_ACQUIRE</span>
        <span class="c1"># echo time (ms)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">te</span> <span class="o">=</span> <span class="n">te</span>
        <span class="c1"># repetition time (ms)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tr</span> <span class="o">=</span> <span class="n">tr</span>
        <span class="c1"># number of averages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">=</span> <span class="n">na</span>
        <span class="c1"># number of dummy scans</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span>
        <span class="c1"># which nuclei we are pulsing on/looking at (examples: &#39;1H&#39;, &#39;31P&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nuclei</span> <span class="o">=</span> <span class="n">nuclei</span>
        <span class="c1"># number of acquired time points (int)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npts</span> <span class="o">=</span> <span class="n">npts</span>
        <span class="c1"># voxel dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">voxel_size</span> <span class="o">=</span> <span class="n">voxel_size</span>
        <span class="c1"># sampling frequency (Hz)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span>
        <span class="c1"># larmor frequency of water (MHz)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f0</span> <span class="o">=</span> <span class="n">f0</span>
        <span class="c1"># reference voltage (V)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vref</span> <span class="o">=</span> <span class="n">vref</span>
        <span class="c1"># shim vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shims</span> <span class="o">=</span> <span class="n">shims</span>
        <span class="c1"># start timestamp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">timestamp</span>
        <span class="c1"># gating mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gating_mode</span> <span class="o">=</span> <span class="n">gating_mode</span>
        <span class="c1"># effective acquisition time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eff_acquisition_time</span> <span class="o">=</span> <span class="n">eff_acquisition_time</span>
        <span class="c1"># kind of receiver gain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">=</span> <span class="n">scaling_factor</span>
        <span class="c1"># ppm shift (ppm)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ppm_water</span> <span class="o">=</span> <span class="mf">4.7</span>
        <span class="c1"># some 0th phase to add? (rd)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">additional_phi0</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># metabolite_basis_set object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_bs</span> <span class="o">=</span> <span class="n">metabolite_basis_set</span><span class="p">()</span>

        <span class="c1"># try to simplify spin systems when possible to speed up simulations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_spin_system_simplification</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># NMR simulation option: when hard zero-duration RF pulse are employed, should we take into account the duration of the real pulses in the evolution times or not? Experimentally, looks like yes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_evolution_during_hard_pulses</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># band-pass filter signals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bandpass_filter_range_ppm</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># in case GAMMA could not be loaded, we can load the sequence from a stored file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db_file</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># pre-calculated stuff</span>
        <span class="c1"># &#39;metabase&#39;: set of numerically computed metabolite FID signals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_signals</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># time vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># last parameter call</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_params</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_model</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># initialized or not</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="mrs_sequence.copy"><a class="viewcode-back" href="../../mrs.html#mrs.sim.mrs_sequence.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy method.&quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meta_signals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_meta_signals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meta_signals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_last_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">obj</span><span class="o">.</span><span class="n">_last_model</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ready</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property get function for _ready.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self._ready : bool</span>
<span class="sd">            to tell if the object if initialized or not</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ready</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">meta_bs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property get function for meta_bs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self._meta_bs : metabolite_basis_set object</span>
<span class="sd">            Metabolite database to use for simulation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meta_bs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_pulses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Virtual method which initialize RF pulse waveforms if any.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_prepare_spin_system</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metabolite</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return pyGAMMA spin system for a given metabolite, knowing all its properties. Simplify the system in simple cases like singulets (one single chemical shift, no J-couplings).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        metabolite : dict</span>
<span class="sd">            metabolite_basis_set entry for one single metabolite</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sys : pyGAMMA system object</span>
<span class="sd">            Spin system object used for simulation</span>
<span class="sd">        scaling_factor : float</span>
<span class="sd">            Scaling factor after system simplification</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;preparing spin system&quot;</span><span class="p">)</span>

        <span class="c1"># init</span>
        <span class="n">scaling_factor</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># extract metabolite properties needed to create spin system</span>
        <span class="n">ppm</span> <span class="o">=</span> <span class="n">metabolite</span><span class="p">[</span><span class="s2">&quot;ppm&quot;</span><span class="p">]</span>
        <span class="n">iso</span> <span class="o">=</span> <span class="n">metabolite</span><span class="p">[</span><span class="s2">&quot;iso&quot;</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">metabolite</span><span class="p">[</span><span class="s2">&quot;J&quot;</span><span class="p">]</span>

        <span class="c1"># check if we can simplify</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allow_spin_system_simplification</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ppm</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ppm</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;simplifying the spin system&quot;</span><span class="p">)</span>
            <span class="c1"># we have a non-coupled singulet with N spins here</span>
            <span class="c1"># let&#39;s simplify to one single spin + amplification factor</span>
            <span class="n">scaling_factor</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ppm</span><span class="p">))</span>
            <span class="n">ppm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ppm</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">iso</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">iso</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

        <span class="c1"># init system</span>
        <span class="n">nSpins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ppm</span><span class="p">)</span>
        <span class="n">sys</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">spin_system</span><span class="p">(</span><span class="n">nSpins</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">Omega</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f0</span><span class="p">)</span>

        <span class="c1"># for each spin</span>
        <span class="k">for</span> <span class="n">i_spin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nSpins</span><span class="p">):</span>
            <span class="c1"># set the nuclei</span>
            <span class="k">if</span><span class="p">(</span><span class="n">iso</span><span class="p">[</span><span class="n">i_spin</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">isotope</span><span class="p">(</span><span class="n">i_spin</span><span class="p">,</span> <span class="s1">&#39;1H&#39;</span><span class="p">)</span>
            <span class="k">elif</span><span class="p">(</span><span class="n">iso</span><span class="p">[</span><span class="n">i_spin</span><span class="p">]</span> <span class="o">==</span> <span class="mi">14</span><span class="p">):</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">isotope</span><span class="p">(</span><span class="n">i_spin</span><span class="p">,</span> <span class="s1">&#39;14N&#39;</span><span class="p">)</span>
            <span class="k">elif</span><span class="p">(</span><span class="n">iso</span><span class="p">[</span><span class="n">i_spin</span><span class="p">]</span> <span class="o">==</span> <span class="mi">31</span><span class="p">):</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">isotope</span><span class="p">(</span><span class="n">i_spin</span><span class="p">,</span> <span class="s1">&#39;31P&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
                <span class="c1">#log.error(str(iso[i_spin]) + &quot;, that is weird nuclei!&quot;)</span>

            <span class="c1"># set the ppm</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">PPM</span><span class="p">(</span><span class="n">i_spin</span><span class="p">,</span> <span class="n">ppm</span><span class="p">[</span><span class="n">i_spin</span><span class="p">])</span>

            <span class="c1"># set the couplings</span>
            <span class="k">for</span> <span class="n">icolJ</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i_spin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ppm</span><span class="p">)):</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">J</span><span class="p">(</span><span class="n">i_spin</span><span class="p">,</span> <span class="n">icolJ</span><span class="p">,</span> <span class="n">j</span><span class="p">[</span><span class="n">i_spin</span><span class="p">,</span> <span class="n">icolJ</span><span class="p">])</span>

        <span class="c1"># water shift</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">offsetShifts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppm_water</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">f0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuclei</span><span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_run_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metabolite</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the NMR signal acquired using a single-pulse experiment using the GAMMA library via the pyGAMMA python wrapper for one metabolite (=one spin system).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        metabolite : dict</span>
<span class="sd">            metabolite_basis_set entry for one single metabolite</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        s_MRSData2 : MRSData2 object</span>
<span class="sd">            Containing the MRS signal simulated for this metabolite</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;acquiring pulse-acquire sequence: (90)...&quot;</span><span class="p">)</span>
        <span class="c1"># create spin system</span>
        <span class="n">sys</span><span class="p">,</span> <span class="n">amp_factor_spins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_spin_system</span><span class="p">(</span><span class="n">metabolite</span><span class="p">)</span>

        <span class="c1"># amplitude normalization</span>
        <span class="n">afactor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">/</span> <span class="n">sys</span><span class="o">.</span><span class="n">HS</span><span class="p">()</span>

        <span class="c1"># coupling</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">Hcs</span><span class="p">(</span><span class="n">sys</span><span class="p">)</span> <span class="o">+</span> <span class="n">pg</span><span class="o">.</span><span class="n">HJ</span><span class="p">(</span><span class="n">sys</span><span class="p">)</span>

        <span class="c1"># detection stuff</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">Fm</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuclei</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span>

        <span class="c1"># run the pulse-acquire experiment</span>
        <span class="n">sigma0</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">sigma_eq</span><span class="p">(</span><span class="n">sys</span><span class="p">)</span>
        <span class="n">te_real</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1"># excitation: hard 90 pulse</span>
        <span class="n">sigma1</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">Iypuls</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">sigma0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuclei</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">)</span>
        <span class="n">te_real</span> <span class="o">+=</span> <span class="mf">0.0</span>
        <span class="c1"># evolution</span>
        <span class="n">sigma0</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">pg</span><span class="o">.</span><span class="n">prop</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">te</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">))</span>  <span class="c1"># TE evolution</span>
        <span class="n">te_real</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">te</span> <span class="o">/</span> <span class="mf">1000.0</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">FID</span><span class="p">(</span><span class="n">sigma0</span><span class="p">,</span> <span class="n">pg</span><span class="o">.</span><span class="n">gen_op</span><span class="p">(</span><span class="n">D</span><span class="p">),</span> <span class="n">H</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">)</span>  <span class="c1"># acquisition</span>

        <span class="c1"># extract complex time data points</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">,</span> <span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">):</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">afactor</span> <span class="o">*</span> <span class="n">amp_factor_spins</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">getRe</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">getIm</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="c1"># convert to suspect</span>
        <span class="n">s_MRSData</span> <span class="o">=</span> <span class="n">suspect</span><span class="o">.</span><span class="n">MRSData</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f0</span><span class="p">)</span>
        <span class="n">s_MRSData2</span> <span class="o">=</span> <span class="n">s_MRSData</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">reco</span><span class="o">.</span><span class="n">MRSData2</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;done. (real TE=</span><span class="si">%.2f</span><span class="s2">ms)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">te_real</span> <span class="o">*</span> <span class="mf">1000.0</span><span class="p">))</span>

        <span class="k">return</span><span class="p">(</span><span class="n">s_MRSData2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compute_metabolite_signals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For each goup of metabolites, generate the simulated MRS signal.&quot;&quot;&quot;</span>
        <span class="c1"># clear metabase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_signals</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># zero signal vector</span>
        <span class="n">s_full_meta</span> <span class="o">=</span> <span class="n">suspect</span><span class="o">.</span><span class="n">MRSData</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">,</span> <span class="p">]),</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f0</span><span class="p">)</span>
        <span class="n">s_full_meta</span> <span class="o">=</span> <span class="n">s_full_meta</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">reco</span><span class="o">.</span><span class="n">MRSData2</span><span class="p">)</span>

        <span class="c1"># browse though the database and display everything</span>
        <span class="k">for</span> <span class="n">this_metagroup_key</span><span class="p">,</span> <span class="n">this_metagroup_entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meta_bs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">s_grp</span> <span class="o">=</span> <span class="n">s_full_meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">this_meta_key</span><span class="p">,</span> <span class="n">this_meta_entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meta_bs</span><span class="p">[</span><span class="n">this_metagroup_key</span><span class="p">][</span><span class="s2">&quot;metabolites&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;simulating MRS signal for metabolite [</span><span class="si">%s</span><span class="s2">/</span><span class="si">%s</span><span class="s2">]...&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">this_metagroup_key</span><span class="p">,</span> <span class="n">this_meta_key</span><span class="p">))</span>
                <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_sequence</span><span class="p">(</span><span class="n">this_meta_entry</span><span class="p">)</span>
                
                <span class="c1"># band pass filter?</span>
                <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bandpass_filter_range_ppm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="c1">#s = s.correct_bandpass_filtering_1d(self.bandpass_filter_range_ppm, np.ones)</span>
                    <span class="c1"># first any peaks outside of range?</span>
                    <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">this_meta_entry</span><span class="p">[</span><span class="s2">&quot;ppm&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bandpass_filter_range_ppm</span><span class="p">)))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">this_meta_entry</span><span class="p">[</span><span class="s2">&quot;ppm&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bandpass_filter_range_ppm</span><span class="p">)))</span> <span class="p">):</span>
                        <span class="c1"># yes, so count them on the right side</span>
                        <span class="n">n_peaks2remove</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">this_meta_entry</span><span class="p">[</span><span class="s2">&quot;ppm&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bandpass_filter_range_ppm</span><span class="p">))</span>
                        <span class="c1"># and remove them</span>
                        <span class="k">if</span><span class="p">(</span><span class="n">n_peaks2remove</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">correct_peak_removal_1d</span><span class="p">(</span><span class="n">n_peaks2remove</span> <span class="o">*</span> <span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">this_meta_entry</span><span class="p">[</span><span class="s2">&quot;ppm&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bandpass_filter_range_ppm</span><span class="p">)],</span> <span class="kc">False</span><span class="p">)</span>
                        <span class="c1"># now, count them on the left side</span>
                        <span class="n">n_peaks2remove</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">this_meta_entry</span><span class="p">[</span><span class="s2">&quot;ppm&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bandpass_filter_range_ppm</span><span class="p">))</span>
                        <span class="c1"># and remove them</span>
                        <span class="k">if</span><span class="p">(</span><span class="n">n_peaks2remove</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">correct_peak_removal_1d</span><span class="p">(</span><span class="n">n_peaks2remove</span> <span class="o">*</span> <span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bandpass_filter_range_ppm</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">this_meta_entry</span><span class="p">[</span><span class="s2">&quot;ppm&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span> <span class="kc">False</span><span class="p">)</span>
                        
                <span class="c1"># build up the metabolite group</span>
                <span class="n">s_grp</span> <span class="o">=</span> <span class="n">s_grp</span> <span class="o">+</span> <span class="n">s</span>
                
            <span class="c1"># append this metabolite group to the metabase</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meta_signals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s_grp</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_load_from_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">te_tol</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">f0_tol</span><span class="o">=</span><span class="mf">5.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Try to load the simulated metabolite signals from a stored PKL file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        te_tol : float</span>
<span class="sd">            Maximum TE difference tolerated when looking for a sequence (ms)</span>
<span class="sd">        f0_tol : float</span>
<span class="sd">            Maximum f0 difference tolerated when looking for a sequence (MHz)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;pyGAMMA library could not be loaded and no sequence database PKL file (db_file) was specified :(&quot;</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;reading sequence database file...&quot;</span><span class="p">)</span>
        <span class="c1"># load pickle file</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_file</span><span class="p">)</span>

        <span class="c1"># compare sequences</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;trying to find the right simulated sequence for you...&quot;</span><span class="p">)</span>

        <span class="c1"># sequence excitation type</span>
        <span class="n">df_exc_type</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;sequence_exc_type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">exc_type</span><span class="p">]</span>
        <span class="n">n_exc_type</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_exc_type</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;sequence type match: n=</span><span class="si">%d</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_exc_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exc_type</span><span class="p">))</span>

        <span class="c1"># sequence name</span>
        <span class="n">df_name</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;sequence_name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="n">n_name</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_name</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;sequence name match: n=</span><span class="si">%d</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="c1"># initialize final mask</span>
        <span class="c1"># if cannot find exact sequence name, at least choose a similar excitation scheme (spin-echo or stim for example)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">n_name</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df_exc_type</span>

        <span class="c1"># nuclei</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;sequence_nuclei&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuclei</span><span class="p">]</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;nuclei match: n=</span><span class="si">%d</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuclei</span><span class="p">))</span>

        <span class="c1"># f0 (with tolerance)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;sequence_f0&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f0</span> <span class="o">-</span> <span class="n">f0_tol</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;sequence_f0&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f0</span> <span class="o">+</span> <span class="n">f0_tol</span><span class="p">))]</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;f0 match: need </span><span class="si">%.3f</span><span class="s2">MHz, found n=</span><span class="si">%d</span><span class="s2"> sequences simulated at +/-</span><span class="si">%.3f</span><span class="s2">MHz&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">f0_tol</span><span class="p">))</span>

        <span class="c1"># ppm water</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;sequence_ppm_water&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppm_water</span><span class="p">]</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;water ppm match: n=</span><span class="si">%d</span><span class="s2"> (</span><span class="si">%.2f</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppm_water</span><span class="p">))</span>

        <span class="c1"># additional_phi0</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;sequence_additional_phi0&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_phi0</span><span class="p">]</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;0th order phase match: n=</span><span class="si">%d</span><span class="s2"> (</span><span class="si">%.2f</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_phi0</span><span class="p">))</span>

        <span class="c1"># allow_evolution_during_hard_pulses</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;sequence_allow_evolution_during_hard_pulses&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_evolution_during_hard_pulses</span><span class="p">]</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;complicated stuff match: n=</span><span class="si">%d</span><span class="s2"> (</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_evolution_during_hard_pulses</span><span class="p">))</span>

        <span class="c1"># metabolites</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;sequence_metabolite_basisset_obj_eq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">json_normalize</span><span class="p">(</span><span class="n">mb</span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">json_normalize</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_bs</span><span class="p">)))</span> <span class="k">for</span> <span class="n">mb</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;sequence_metabolite_basisset_obj&quot;</span><span class="p">]]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;sequence_metabolite_basisset_basis_set_name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_bs</span><span class="o">.</span><span class="n">basis_set_name</span><span class="p">)</span> <span class="o">&amp;</span>
                            <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;sequence_metabolite_basisset_obj_eq&quot;</span><span class="p">])]</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;metabolites match: n=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">))</span>

        <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;sorry, there is no simulated sequence that matches with your acquisition criterias :(&quot;</span><span class="p">)</span>

        <span class="c1"># te: look for closest</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;te_diff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;sequence_te&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">te</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
        <span class="n">found_sequence</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;te_diff&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;sequence_obj&quot;</span><span class="p">]</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;TE match: need </span><span class="si">%.2f</span><span class="s2">ms, found </span><span class="si">%.2f</span><span class="s2">ms&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">te</span><span class="p">,</span> <span class="n">found_sequence</span><span class="o">.</span><span class="n">te</span><span class="p">))</span>

        <span class="c1"># check if below tolerance</span>
        <span class="n">te_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">te</span> <span class="o">-</span> <span class="n">found_sequence</span><span class="o">.</span><span class="n">te</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">te_diff</span> <span class="o">&gt;</span> <span class="n">te_tol</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_bs</span><span class="o">.</span><span class="n">non_coupled_only</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;TE match: the difference might seem a lot but I see you want to generate only singulet&#39;s metabolites so that is really not a big deal ;)&quot;</span><span class="p">)</span>

        <span class="c1"># display</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;comparing what you asked/what you got...&quot;</span><span class="p">)</span>
        <span class="n">df_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span>
        <span class="n">df_self</span><span class="p">[</span><span class="s2">&quot;Index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Current&quot;</span>
        <span class="n">df_found</span> <span class="o">=</span> <span class="n">found_sequence</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span>
        <span class="n">df_found</span><span class="p">[</span><span class="s2">&quot;Index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Found&quot;</span>
        <span class="n">df_display</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df_self</span><span class="p">,</span> <span class="n">df_found</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">df_display</span> <span class="o">=</span> <span class="n">df_display</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;Index&quot;</span><span class="p">)</span>
        <span class="n">display</span><span class="p">(</span><span class="n">df_display</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># ok well done. Now we maybe have to fix a few issues: number of samples, sampling frequency, amplification factor, this can be done with some signal processing stuff</span>

        <span class="c1"># resampling (even if not needed)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;resampling metabolite signals: </span><span class="si">%d</span><span class="s2">pts/</span><span class="si">%.2f</span><span class="s2">Hz to </span><span class="si">%d</span><span class="s2">pts/</span><span class="si">%.2f</span><span class="s2">Hz...&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">found_sequence</span><span class="o">.</span><span class="n">npts</span><span class="p">,</span> <span class="n">found_sequence</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">))</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;rescaling metabolite signals by a factor of </span><span class="si">%.2f</span><span class="s2">...&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">/</span> <span class="n">found_sequence</span><span class="o">.</span><span class="n">scaling_factor</span><span class="p">))</span>
        <span class="n">old_dt</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">found_sequence</span><span class="o">.</span><span class="n">fs</span>
        <span class="n">old_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">found_sequence</span><span class="o">.</span><span class="n">npts</span> <span class="o">*</span> <span class="n">old_dt</span><span class="p">,</span> <span class="n">old_dt</span><span class="p">)</span>
        <span class="n">new_dt</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span>
        <span class="n">new_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span> <span class="o">*</span> <span class="n">new_dt</span><span class="p">,</span> <span class="n">new_dt</span><span class="p">)</span>

        <span class="c1"># resample each metabolite signal</span>
        <span class="n">new_meta_signals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">found_sequence</span><span class="o">.</span><span class="n">_meta_signals</span><span class="p">:</span>
            <span class="n">s2_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">new_t</span><span class="p">,</span> <span class="n">old_t</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
            <span class="c1"># convert to suspect</span>
            <span class="n">s_MRSData</span> <span class="o">=</span> <span class="n">suspect</span><span class="o">.</span><span class="n">MRSData</span><span class="p">(</span><span class="n">s2_np</span><span class="p">,</span> <span class="n">new_dt</span><span class="p">,</span> <span class="n">found_sequence</span><span class="o">.</span><span class="n">f0</span><span class="p">)</span>
            <span class="n">s_MRSData2</span> <span class="o">=</span> <span class="n">s_MRSData</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">reco</span><span class="o">.</span><span class="n">MRSData2</span><span class="p">)</span>
            <span class="c1"># rescale</span>
            <span class="n">s_MRSData2</span> <span class="o">=</span> <span class="n">s_MRSData2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">/</span> <span class="n">found_sequence</span><span class="o">.</span><span class="n">scaling_factor</span>
            <span class="c1"># and rebuild metabase</span>
            <span class="n">new_meta_signals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s_MRSData2</span><span class="p">)</span>

        <span class="c1"># final: carefully copy attributes except some</span>
        <span class="n">keys_not_to_copy</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;_meta_bs&quot;</span><span class="p">,</span> <span class="s2">&quot;_meta_signals&quot;</span><span class="p">,</span> <span class="s2">&quot;_t&quot;</span><span class="p">,</span> <span class="s2">&quot;_ready&quot;</span><span class="p">,</span> <span class="s2">&quot;_last_params&quot;</span><span class="p">,</span> <span class="s2">&quot;_last_model&quot;</span><span class="p">,</span> <span class="s2">&quot;npts&quot;</span><span class="p">,</span> <span class="s2">&quot;fs&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">this_key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span><span class="p">(</span><span class="n">this_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys_not_to_copy</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">this_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">found_sequence</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">this_key</span><span class="p">]</span>

        <span class="c1"># apply changes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="n">new_t</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_signals</span> <span class="o">=</span> <span class="n">new_meta_signals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># reinit meta_bs aliases</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_bs</span><span class="o">.</span><span class="n">_write_header_file</span><span class="p">()</span>

        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;successfully imported metabolite signal basis set! :)&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="mrs_sequence.initialize"><a class="viewcode-back" href="../../mrs.html#mrs.sim.mrs_sequence.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meta_bs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the sequence object before using it to simulate MRS signals.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        meta_bs : metabolite_basis_set</span>
<span class="sd">            Metabolite database to use for simulation. If none specified, use default metabolite_basis_set object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># want to use a custom metabolite db?</span>
        <span class="k">if</span><span class="p">(</span><span class="n">meta_bs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meta_bs</span> <span class="o">=</span> <span class="n">meta_bs</span>
            <span class="c1"># force update header file aliases.py</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meta_bs</span><span class="o">.</span><span class="n">_write_header_file</span><span class="p">()</span>

        <span class="c1"># wait, was the GAMMA library imported ok?</span>
        <span class="k">if</span><span class="p">(</span><span class="n">GAMMA_LIB_LOADED</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;initializing sequence using pyGAMMA...&quot;</span><span class="p">)</span>
            <span class="c1"># oh ok, so let&#39;s run the simulations and stuff</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_pulses</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_metabolite_signals</span><span class="p">()</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span> <span class="o">*</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;loading sequence from disk...&quot;</span><span class="p">)</span>
            <span class="c1"># ops, so let&#39;s try to load the simulations from a pkl file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_from_file</span><span class="p">()</span>

        <span class="c1"># initialize the model persistent memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_params</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_model</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="k">def</span> <span class="nf">_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Most important function in here... Simulates the MRS signal using a parametric model that allows the control in amplitude, linewidth, frequency and phase shift for each metabolite.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        p : params object</span>
<span class="sd">            Array of simulation parameters</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        s : MRSData2 numpy array [timepoints]</span>
<span class="sd">            Modeled MRS data signal stored in a MRSData2 object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ready or not, here I come</span>
        <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ready</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;this mrs_sequence object was not initialized!&quot;</span><span class="p">)</span>

        <span class="c1"># check last call</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_params</span> <span class="o">==</span> <span class="n">p</span><span class="p">)):</span>
            <span class="c1"># we are asking for the same model than last time</span>
            <span class="c1"># calling back persistent momery</span>
            <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_model</span><span class="p">)</span>

        <span class="c1"># time MRS model</span>
        <span class="n">s_MRSData</span> <span class="o">=</span> <span class="n">suspect</span><span class="o">.</span><span class="n">MRSData</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">,</span> <span class="p">]),</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f0</span><span class="p">)</span>
        <span class="n">s_MRSData2</span> <span class="o">=</span> <span class="n">s_MRSData</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">reco</span><span class="o">.</span><span class="n">MRSData2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">s_meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meta_signals</span><span class="p">):</span>
            <span class="n">s_MRSData2</span> <span class="o">=</span> <span class="n">s_MRSData2</span> <span class="o">+</span> <span class="n">s_meta</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_phi0</span><span class="p">))</span>

        <span class="c1"># remember</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_params</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_model</span> <span class="o">=</span> <span class="n">s_MRSData2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span><span class="p">(</span><span class="n">s_MRSData2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_jac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the jacobian vector: helps optimization, need for CRBs estimation and parameter correlation matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        p : params object</span>
<span class="sd">            Array of simulation parameters</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        j : numpy array [number of metabolites,number of parameters,number of time points]</span>
<span class="sd">            Jacobian vector, has to be reformatted before use with fit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ready or not, here I come</span>
        <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ready</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;this mrs_sequence object was not initialized!&quot;</span><span class="p">)</span>

        <span class="c1"># for each metabolite, caculate derivative for each parameter</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meta_signals</span><span class="p">),</span> <span class="mi">4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">s_meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_meta_signals</span><span class="p">):</span>
            <span class="c1"># for each parameter, calculate derivative</span>
            <span class="c1"># pre-calculate exp term for this metabolite</span>
            <span class="n">exp_term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_phi0</span><span class="p">))</span>
            <span class="c1"># concentration</span>
            <span class="n">j</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">s_meta</span> <span class="o">*</span> <span class="n">exp_term</span>
            <span class="c1"># damping</span>
            <span class="n">j</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">s_meta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">*</span> <span class="n">exp_term</span>
            <span class="c1"># freq</span>
            <span class="n">j</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">s_meta</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">*</span> <span class="n">exp_term</span>
            <span class="c1"># phase</span>
            <span class="n">j</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">s_meta</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">exp_term</span>

        <span class="k">return</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

<div class="viewcode-block" id="mrs_sequence.simulate_signal"><a class="viewcode-back" href="../../mrs.html#mrs.sim.mrs_sequence.simulate_signal">[docs]</a>    <span class="k">def</span> <span class="nf">simulate_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">sigma_noise</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">lbl</span><span class="o">=</span><span class="s2">&quot;simulated MRS signal&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print out the parameter values and returns the modeled signal using above member function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        p : params object</span>
<span class="sd">            Array of simulation parameters</span>
<span class="sd">        sigma_noise : float</span>
<span class="sd">            Noise level</span>
<span class="sd">        na : int</span>
<span class="sd">            Number of averages</span>
<span class="sd">        lbl : string</span>
<span class="sd">            Label describing simulated data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        s : MRSData2 numpy array [timepoints]</span>
<span class="sd">            Simulated MRS data signal stored in a MRSData2 object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ready or not, here I come</span>
        <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ready</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;this mrs_sequence object was not initialized!&quot;</span><span class="p">)</span>

        <span class="c1"># checking if LL is not broken</span>
        <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">check</span><span class="p">()):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;the link-lock vector of this params object looks broken!&quot;</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;simulating signal...&quot;</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">if</span><span class="p">(</span><span class="n">sigma_noise</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">na</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># simple noisy 1 shot simulation</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;adding complex gaussian noise, std. deviation = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sigma_noise</span><span class="p">))</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sigma_noise</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>

        <span class="k">elif</span><span class="p">(</span><span class="n">sigma_noise</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">na</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># averaged noisy simulation</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="n">progressbar</span><span class="p">(</span><span class="s2">&quot;averaging&quot;</span><span class="p">,</span> <span class="n">na</span><span class="p">)</span>
            <span class="n">s_single_shot</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">s_averaged</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">na</span><span class="p">):</span>
                <span class="n">s_averaged</span> <span class="o">+=</span> <span class="n">s_single_shot</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sigma_noise</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
                <span class="n">b</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">b</span><span class="o">.</span><span class="n">finish</span><span class="p">(</span><span class="s2">&quot;done&quot;</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s_averaged</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;ambiguous arguments: simulating a single-shot signal without noise!&quot;</span><span class="p">)</span>

        <span class="c1"># adding a few attributes</span>
        <span class="n">s</span><span class="o">.</span><span class="n">_te</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">te</span>
        <span class="n">s</span><span class="o">.</span><span class="n">_sequence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">s</span><span class="o">.</span><span class="n">analyze_noise_nd</span><span class="p">()</span>
        <span class="n">s</span><span class="o">.</span><span class="n">set_display_label</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>

<div class="viewcode-block" id="mrs_sequence.to_dataframe"><a class="viewcode-back" href="../../mrs.html#mrs.sim.mrs_sequence.to_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">to_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_obj</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">prefix_str</span><span class="o">=</span><span class="s2">&quot;sequence_&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the object&#39;s attributes to dataframe. Can include the object itself.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        include_obj : boolean</span>
<span class="sd">            Include self to the dataframe row</span>
<span class="sd">        prefix_str : string</span>
<span class="sd">            Prefix string to add to column names</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df : Dataframe</span>
<span class="sd">            Containing the attributes as columns (a single row)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;converting to dataframe...&quot;</span><span class="p">)</span>

        <span class="c1"># get all attributes but remove the private ones</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">([</span><span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)])</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">regex</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;^(?!_).*&quot;</span><span class="p">))</span>

        <span class="k">if</span><span class="p">(</span><span class="n">include_obj</span><span class="p">):</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;obj&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># add private attribute _meta_bs</span>
        <span class="n">df_meta_bs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meta_bs</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">df_meta_bs</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">add_prefix</span><span class="p">(</span><span class="n">prefix_str</span><span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="mrs_seq_press"><a class="viewcode-back" href="../../mrs.html#mrs.sim.mrs_seq_press">[docs]</a><span class="k">class</span> <span class="nc">mrs_seq_press</span><span class="p">(</span><span class="n">mrs_sequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that represents a general PRESS sequence.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="o">=</span><span class="mf">3500.0</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">ds</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">nuclei</span><span class="o">=</span><span class="s2">&quot;1H&quot;</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="mi">4096</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">voxel_size</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="mf">5000.0</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="mf">297.2062580</span><span class="p">,</span> <span class="n">vref</span><span class="o">=</span><span class="mf">250.0</span><span class="p">,</span> <span class="n">shims</span><span class="o">=</span><span class="p">[],</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">gating_mode</span><span class="o">=</span><span class="n">gating_signal_source</span><span class="o">.</span><span class="n">NO_GATING</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">te1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">te2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a virtual PRESS sequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        te : float</span>
<span class="sd">            Echo time (ms)</span>
<span class="sd">        tr : float</span>
<span class="sd">            Repetition time (ms)</span>
<span class="sd">        na : int</span>
<span class="sd">            Number of averages/excitations</span>
<span class="sd">        ds : int</span>
<span class="sd">            Number of summy scans</span>
<span class="sd">        nuclei : string</span>
<span class="sd">            Observed nuclei. Examples: &quot;1H&quot;, &quot;31P&quot;, etc.</span>
<span class="sd">        npts : int</span>
<span class="sd">            Number of acquisition points</span>
<span class="sd">        voxel_size : list</span>
<span class="sd">            Dimensions of voxel (mm)</span>
<span class="sd">        fs : float</span>
<span class="sd">            Acquisition bandwidth (Hz)</span>
<span class="sd">        f0 : float</span>
<span class="sd">            Water Larmor frequency (MHz)</span>
<span class="sd">        vref : float</span>
<span class="sd">            Reference voltage (V)</span>
<span class="sd">        shims : list of floats</span>
<span class="sd">            List of shim voltages in volts</span>
<span class="sd">        timestamp : float</span>
<span class="sd">            Timestamp in ms</span>
<span class="sd">        gating_mode : gating_signal_source</span>
<span class="sd">            Acquisition triggering mode</span>
<span class="sd">        eff_acquisition_time : float</span>
<span class="sd">            Effective acquisition time (s)</span>
<span class="sd">        scaling_factor : float</span>
<span class="sd">            Scaling FID intensity factor</span>
<span class="sd">        te1 : float</span>
<span class="sd">            First part of TE (ms)</span>
<span class="sd">        te2 : float</span>
<span class="sd">            Second part of TE (ms)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">nuclei</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">voxel_size</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">vref</span><span class="p">,</span> <span class="n">shims</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">gating_mode</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="p">)</span>
        <span class="c1"># name of sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;press (not specific)&quot;</span>
        <span class="c1"># type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exc_type</span> <span class="o">=</span> <span class="n">sequence_exc_type</span><span class="o">.</span><span class="n">SPIN_ECHO</span>
        <span class="c1"># TE timing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">te</span> <span class="o">=</span> <span class="n">te</span>
        <span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">te1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">te2</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">te1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">te</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">te2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">te</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">te1</span> <span class="o">=</span> <span class="n">te1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">te2</span> <span class="o">=</span> <span class="n">te2</span>

        <span class="c1"># flip phase for PRESS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">additional_phi0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="c1"># freeze</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__isfrozen</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_run_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metabolite</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the NMR signal acquired using a PRESS sequence using the GAMMA library via the pyGAMMA python wrapper for one metabolite (=one spin system).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        metabolite : dict</span>
<span class="sd">            metabolite_basis_set entry for one single metabolite</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        s_MRSData2 : MRSData2 object</span>
<span class="sd">            Containing the MRS signal simulated for this metabolite</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;acquiring PRESS sequence: (90)-(180)-(180)...&quot;</span><span class="p">)</span>
        <span class="c1"># create spin system</span>
        <span class="n">sys</span><span class="p">,</span> <span class="n">amp_factor_spins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_spin_system</span><span class="p">(</span><span class="n">metabolite</span><span class="p">)</span>

        <span class="c1"># amplitude normalization</span>
        <span class="n">afactor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">/</span> <span class="n">sys</span><span class="o">.</span><span class="n">HS</span><span class="p">()</span>

        <span class="c1"># coupling</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">Hcs</span><span class="p">(</span><span class="n">sys</span><span class="p">)</span> <span class="o">+</span> <span class="n">pg</span><span class="o">.</span><span class="n">HJ</span><span class="p">(</span><span class="n">sys</span><span class="p">)</span>

        <span class="c1"># detection stuff</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">Fm</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuclei</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span>

        <span class="c1"># PRESS timing implementation</span>
        <span class="c1"># 90-a-180-b-c-180-d-FID</span>
        <span class="c1"># all in ms</span>
        <span class="c1"># TE1/TE2 timing</span>
        <span class="n">ab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">te1</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">te2</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">ab</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="n">ab</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="n">cd</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">cd</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="c1"># delay list in seconds</span>
        <span class="n">evol_delays_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span> <span class="o">/</span> <span class="mf">1000.0</span>
        <span class="c1"># flip angle list</span>
        <span class="n">flip_angles_deg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">90.0</span><span class="p">,</span> <span class="mf">180.0</span><span class="p">,</span> <span class="mf">180.0</span><span class="p">])</span>

        <span class="c1"># run the sequence</span>
        <span class="n">sigma0</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">sigma_eq</span><span class="p">(</span><span class="n">sys</span><span class="p">)</span>
        <span class="n">te_real</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># excitation: hard 90 pulse</span>
        <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">evol_delays_s</span><span class="p">,</span> <span class="n">flip_angles_deg</span><span class="p">):</span>
            <span class="n">sigma1</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">Iypuls</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">sigma0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuclei</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
            <span class="n">te_real</span> <span class="o">+=</span> <span class="mf">0.0</span>
            <span class="c1"># evolution</span>
            <span class="n">sigma0</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">pg</span><span class="o">.</span><span class="n">prop</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
            <span class="n">te_real</span> <span class="o">+=</span> <span class="n">d</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">FID</span><span class="p">(</span><span class="n">sigma0</span><span class="p">,</span> <span class="n">pg</span><span class="o">.</span><span class="n">gen_op</span><span class="p">(</span><span class="n">D</span><span class="p">),</span> <span class="n">H</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">)</span>  <span class="c1"># acquisition</span>

        <span class="c1"># extract complex time data points</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">,</span> <span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">):</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">afactor</span> <span class="o">*</span> <span class="n">amp_factor_spins</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">getRe</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">getIm</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="c1"># convert to suspect</span>
        <span class="n">s_MRSData</span> <span class="o">=</span> <span class="n">suspect</span><span class="o">.</span><span class="n">MRSData</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f0</span><span class="p">)</span>
        <span class="n">s_MRSData2</span> <span class="o">=</span> <span class="n">s_MRSData</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">reco</span><span class="o">.</span><span class="n">MRSData2</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;done. (real TE=</span><span class="si">%.2f</span><span class="s2">ms)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">te_real</span> <span class="o">*</span> <span class="mf">1000.0</span><span class="p">))</span>

        <span class="k">return</span><span class="p">(</span><span class="n">s_MRSData2</span><span class="p">)</span></div>


<div class="viewcode-block" id="mrs_seq_steam"><a class="viewcode-back" href="../../mrs.html#mrs.sim.mrs_seq_steam">[docs]</a><span class="k">class</span> <span class="nc">mrs_seq_steam</span><span class="p">(</span><span class="n">mrs_sequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that represents a general STEAM sequence.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="o">=</span><span class="mf">3500.0</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">ds</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">nuclei</span><span class="o">=</span><span class="s2">&quot;1H&quot;</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="mi">4096</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">voxel_size</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="mf">5000.0</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="mf">297.2062580</span><span class="p">,</span> <span class="n">vref</span><span class="o">=</span><span class="mf">250.0</span><span class="p">,</span> <span class="n">shims</span><span class="o">=</span><span class="p">[],</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">gating_mode</span><span class="o">=</span><span class="n">gating_signal_source</span><span class="o">.</span><span class="n">NO_GATING</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">tm</span><span class="o">=</span><span class="mf">20.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a virtual STEAM sequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        te : float</span>
<span class="sd">            Echo time (ms)</span>
<span class="sd">        tr : float</span>
<span class="sd">            Repetition time (ms)</span>
<span class="sd">        na : int</span>
<span class="sd">            Number of averages/excitations</span>
<span class="sd">        ds : int</span>
<span class="sd">            Number of summy scans</span>
<span class="sd">        nuclei : string</span>
<span class="sd">            Observed nuclei. Examples: &quot;1H&quot;, &quot;31P&quot;, etc.</span>
<span class="sd">        npts : int</span>
<span class="sd">            Number of acquisition points</span>
<span class="sd">        voxel_size : list</span>
<span class="sd">            Dimensions of voxel (mm)</span>
<span class="sd">        fs : float</span>
<span class="sd">            Acquisition bandwidth (Hz)</span>
<span class="sd">        f0 : float</span>
<span class="sd">            Water Larmor frequency (MHz)</span>
<span class="sd">        vref : float</span>
<span class="sd">            Reference voltage (V)</span>
<span class="sd">        shims : list of floats</span>
<span class="sd">            List of shim voltages in volts</span>
<span class="sd">        timestamp : float</span>
<span class="sd">            Timestamp in ms</span>
<span class="sd">        gating_mode : gating_signal_source</span>
<span class="sd">            Acquisition triggering mode</span>
<span class="sd">        eff_acquisition_time : float</span>
<span class="sd">            Effective acquisition time (s)</span>
<span class="sd">        scaling_factor : float</span>
<span class="sd">            Scaling FID intensity factor</span>
<span class="sd">        tm : float</span>
<span class="sd">            Mixing time (ms)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">nuclei</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">voxel_size</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">vref</span><span class="p">,</span> <span class="n">shims</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">gating_mode</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="p">)</span>
        <span class="c1"># name of sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;steam (not specific)&quot;</span>
        <span class="c1"># type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exc_type</span> <span class="o">=</span> <span class="n">sequence_exc_type</span><span class="o">.</span><span class="n">STIMULATED_ECHO</span>
        <span class="c1"># mixing time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tm</span> <span class="o">=</span> <span class="n">tm</span>
        <span class="c1"># need some 180deg phase here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">additional_phi0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="c1"># freeze</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__isfrozen</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_run_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metabolite</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the NMR signal acquired using a STEAM sequence using the GAMMA library via the pyGAMMA python wrapper for one metabolite (=one spin system).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        metabolite : dict</span>
<span class="sd">            metabolite_basis_set entry for one single metabolite</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        s_MRSData2 : MRSData2 object</span>
<span class="sd">            Containing the MRS signal simulated for this metabolite</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;acquiring PRESS sequence: (90)-(90)-(90)...&quot;</span><span class="p">)</span>
        <span class="c1"># create spin system</span>
        <span class="n">sys</span><span class="p">,</span> <span class="n">amp_factor_spins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_spin_system</span><span class="p">(</span><span class="n">metabolite</span><span class="p">)</span>

        <span class="c1"># amplitude normalization</span>
        <span class="n">afactor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">/</span> <span class="n">sys</span><span class="o">.</span><span class="n">HS</span><span class="p">()</span>

        <span class="c1"># coupling</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">Hcs</span><span class="p">(</span><span class="n">sys</span><span class="p">)</span> <span class="o">+</span> <span class="n">pg</span><span class="o">.</span><span class="n">HJ</span><span class="p">(</span><span class="n">sys</span><span class="p">)</span>

        <span class="c1"># detection stuff</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">Fm</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuclei</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span>

        <span class="c1"># STEAM timing implementation</span>
        <span class="c1"># 90-a-90-b-90-c-FID</span>
        <span class="c1"># all in ms</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">te</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tm</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">te</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="c1"># delay list in seconds</span>
        <span class="n">evol_delays_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span> <span class="o">/</span> <span class="mf">1000.0</span>

        <span class="c1"># run the sequence</span>
        <span class="n">sigma0</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">sigma_eq</span><span class="p">(</span><span class="n">sys</span><span class="p">)</span>
        <span class="n">te_real</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># 1st 90 pulse</span>
        <span class="n">sigma1</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">Iypuls</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">sigma0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuclei</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">)</span>
        <span class="n">te_real</span> <span class="o">+=</span> <span class="mf">0.0</span>
        <span class="c1"># evolution</span>
        <span class="n">sigma0</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">pg</span><span class="o">.</span><span class="n">prop</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">evol_delays_s</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">te_real</span> <span class="o">+=</span> <span class="n">evol_delays_s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># the following code is from Vespa&#39;s pulse_sequences.xml file</span>
        <span class="c1"># STEAM Ideal version 2 from Brian Soher</span>
        <span class="c1"># seems that whatever TM we have, it will give the same result</span>

        <span class="c1"># Now we need to create the effect of crushers around the 2nd and 3rd</span>
        <span class="c1"># 90 pulses. This is done by creating 4 copies of spin state and repeating</span>
        <span class="c1"># the rest of the sequence for four different rotations around z-axis</span>
        <span class="n">dephase_ang</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">,</span> <span class="mf">180.0</span><span class="p">,</span> <span class="mf">270.0</span><span class="p">]</span>
        <span class="n">sigma_mult</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dephase_ang</span><span class="p">:</span>
            <span class="n">sigma_mult</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pg</span><span class="o">.</span><span class="n">gen_op</span><span class="p">(</span><span class="n">sigma0</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dephase_ang</span><span class="p">):</span>
            <span class="c1"># calculate and apply rotation around z-axis</span>
            <span class="n">riz</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">gen_op</span><span class="p">(</span><span class="n">pg</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>
            <span class="n">sigma_mult</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">sigma_mult</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">riz</span><span class="p">)</span>

            <span class="c1"># second 90 pulse</span>
            <span class="n">sigma_mult</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">Ixpuls</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">sigma_mult</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuclei</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">)</span>

            <span class="c1"># this function removes all coherences still in transverse plane</span>
            <span class="c1"># this removes all stimulated echos from first and second 90 pulse</span>
            <span class="n">pg</span><span class="o">.</span><span class="n">zero_mqc</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">sigma_mult</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># third 90 pulse</span>
            <span class="n">sigma_mult</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">Ixpuls</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">sigma_mult</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuclei</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">)</span>
            <span class="c1"># undo rotation around z-axis</span>
            <span class="n">sigma_mult</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">sigma_mult</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">riz</span><span class="p">)</span>
            <span class="c1"># scale results based on the number of phase angles</span>
            <span class="n">sigma_mult</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dephase_ang</span><span class="p">))</span>

            <span class="c1"># sum up each rotated/unrotated results</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sigma_res</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">gen_op</span><span class="p">(</span><span class="n">sigma_mult</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sigma_res</span> <span class="o">+=</span> <span class="n">sigma_mult</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># last TE/2 nutation</span>
        <span class="n">sigma0</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">sigma_res</span><span class="p">,</span> <span class="n">pg</span><span class="o">.</span><span class="n">prop</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">evol_delays_s</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">te_real</span> <span class="o">+=</span> <span class="n">evol_delays_s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">FID</span><span class="p">(</span><span class="n">sigma0</span><span class="p">,</span> <span class="n">pg</span><span class="o">.</span><span class="n">gen_op</span><span class="p">(</span><span class="n">D</span><span class="p">),</span> <span class="n">H</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">)</span>  <span class="c1"># acquisition</span>

        <span class="c1"># extract complex time data points</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">,</span> <span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">):</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">afactor</span> <span class="o">*</span> <span class="n">amp_factor_spins</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">getRe</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">getIm</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="c1"># convert to suspect</span>
        <span class="n">s_MRSData</span> <span class="o">=</span> <span class="n">suspect</span><span class="o">.</span><span class="n">MRSData</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f0</span><span class="p">)</span>
        <span class="n">s_MRSData2</span> <span class="o">=</span> <span class="n">s_MRSData</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">reco</span><span class="o">.</span><span class="n">MRSData2</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;done. (real TE=</span><span class="si">%.2f</span><span class="s2">ms)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">te_real</span> <span class="o">*</span> <span class="mf">1000.0</span><span class="p">))</span>

        <span class="k">return</span><span class="p">(</span><span class="n">s_MRSData2</span><span class="p">)</span></div>


<div class="viewcode-block" id="mrs_seq_eja_svs_slaser"><a class="viewcode-back" href="../../mrs.html#mrs.sim.mrs_seq_eja_svs_slaser">[docs]</a><span class="k">class</span> <span class="nc">mrs_seq_eja_svs_slaser</span><span class="p">(</span><span class="n">mrs_sequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that represents the semi-LASER sequence from CMRR.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="o">=</span><span class="mf">3500.0</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">ds</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">nuclei</span><span class="o">=</span><span class="s2">&quot;1H&quot;</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="mi">4096</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">voxel_size</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="mf">5000.0</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="mf">297.2062580</span><span class="p">,</span> <span class="n">vref</span><span class="o">=</span><span class="mf">250.0</span><span class="p">,</span> <span class="n">shims</span><span class="o">=</span><span class="p">[],</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">gating_mode</span><span class="o">=</span><span class="n">gating_signal_source</span><span class="o">.</span><span class="n">NO_GATING</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">exc_pulse_duration</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">exc_pulse_voltage</span><span class="o">=</span><span class="mf">350.0</span><span class="p">,</span> <span class="n">rfc_pulse_duration</span><span class="o">=</span><span class="mf">9.0</span><span class="p">,</span> <span class="n">rfc_pulse_fa</span><span class="o">=</span><span class="mf">180.0</span><span class="p">,</span> <span class="n">rfc_pulse_r</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span> <span class="n">rfc_pulse_n</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">rfc_pulse_voltage</span><span class="o">=</span><span class="mf">350.0</span><span class="p">,</span> <span class="n">ref_pulse_voltage</span><span class="o">=</span><span class="mf">300.0</span><span class="p">,</span> <span class="n">spoiler_duration</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a virtual semi-LASER sequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        te : float</span>
<span class="sd">            Echo time (ms)</span>
<span class="sd">        tr : float</span>
<span class="sd">            Repetition time (ms)</span>
<span class="sd">        na : int</span>
<span class="sd">            Number of averages/excitations</span>
<span class="sd">        ds : int</span>
<span class="sd">            Number of summy scans</span>
<span class="sd">        nuclei : string</span>
<span class="sd">            Observed nuclei. Examples: &quot;1H&quot;, &quot;31P&quot;, etc.</span>
<span class="sd">        npts : int</span>
<span class="sd">            Number of acquisition points</span>
<span class="sd">        voxel_size : list</span>
<span class="sd">            Dimensions of voxel (mm)</span>
<span class="sd">        fs : float</span>
<span class="sd">            Acquisition bandwidth (Hz)</span>
<span class="sd">        f0 : float</span>
<span class="sd">            Water Larmor frequency (MHz)</span>
<span class="sd">        vref : float</span>
<span class="sd">            Reference voltage (V)</span>
<span class="sd">        shims : list of floats</span>
<span class="sd">            List of shim voltages in volts</span>
<span class="sd">        timestamp : float</span>
<span class="sd">            Timestamp in ms</span>
<span class="sd">        gating_mode : gating_signal_source</span>
<span class="sd">            Acquisition triggering mode</span>
<span class="sd">        eff_acquisition_time : float</span>
<span class="sd">            Effective acquisition time (s)</span>
<span class="sd">        scaling_factor : float</span>
<span class="sd">            Scaling FID intensity factor</span>
<span class="sd">        exc_pulse_duration : float</span>
<span class="sd">            Excitation pulse duration (ms)</span>
<span class="sd">        exc_pulse_voltage : float</span>
<span class="sd">            Excitation pulse voltage (V)</span>
<span class="sd">        rfc_pulse_duration : float</span>
<span class="sd">            Refocussing pulse duration (ms)</span>
<span class="sd">        rfc_pulse_fa : float</span>
<span class="sd">            Refocussing pulse flip angle, which does not mean much when dealing with HSn pulses (deg)</span>
<span class="sd">        rfc_pulse_r : float</span>
<span class="sd">            AHP HSn refocussing pulse R (Hz.s)</span>
<span class="sd">        rfc_pulse_n : float</span>
<span class="sd">            AHP HSn refocussing pulse N</span>
<span class="sd">        rfc_pulse_voltage : float</span>
<span class="sd">            AHP HSn refocussing pulse voltage (V)</span>
<span class="sd">        spoiler_duration : float</span>
<span class="sd">            Spoiler duration (ms)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">nuclei</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">voxel_size</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">vref</span><span class="p">,</span> <span class="n">shims</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">gating_mode</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="p">)</span>
        <span class="c1"># name of sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;eja_svs_slaser&quot;</span>
        <span class="c1"># type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exc_type</span> <span class="o">=</span> <span class="n">sequence_exc_type</span><span class="o">.</span><span class="n">SPIN_ECHO</span>
        <span class="c1"># excitation and AFP pulse properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_exc_duration</span> <span class="o">=</span> <span class="n">exc_pulse_duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span> <span class="o">=</span> <span class="n">rfc_pulse_duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_flipangle</span> <span class="o">=</span> <span class="n">rfc_pulse_fa</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_r</span> <span class="o">=</span> <span class="n">rfc_pulse_r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_n</span> <span class="o">=</span> <span class="n">rfc_pulse_n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_voltage</span> <span class="o">=</span> <span class="n">rfc_pulse_voltage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_npts</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># no default number of points</span>
        <span class="c1"># spoiler properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spoiler_duration</span> <span class="o">=</span> <span class="n">spoiler_duration</span>

        <span class="c1"># should we use real shaped RF pulses or not</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_real_shape_enable</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># sLASER needs some rephasing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">additional_phi0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="c1"># --- RF power adjustement ---</span>
        <span class="c1"># adjust RF by sweeping B1 power</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_enable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># voltage range to sweep (V)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_voltage_range</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">]</span>
        <span class="c1"># number of measurements in the previous range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_voltage_n</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="c1"># which metabolites should we test (separately)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_metabolites</span> <span class="o">=</span> <span class="p">[</span><span class="n">xxx</span><span class="o">.</span><span class="n">m_Water</span><span class="p">]</span>
        <span class="c1"># margins/threshold parameters to estimate optimal RF power. By default:</span>
        <span class="c1"># [0] 10% last points (for higher power) used for plateau estimation</span>
        <span class="c1"># [1] 10% change allowed</span>
        <span class="c1"># [2] 100% power increase to be sure to be in adiabatic regime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_margins</span> <span class="o">=</span> <span class="p">[</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">]</span>  <span class="c1"># %</span>
        <span class="c1"># display all this in a nice fig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_display</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># final pulse voltage found by optimization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_voltage</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># final pulse flip angle found by optimization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_flipangle</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># RF power (w1 in Hz) used for AFP pulses during simulation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pulse_rfc_w1max</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># interpulse delay lists</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subdelay_c2c_ms_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subdelay_evol_ms_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tcp_ms_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># freeze</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__isfrozen</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="mrs_seq_eja_svs_slaser.get_csde"><a class="viewcode-back" href="../../mrs.html#mrs.sim.mrs_seq_eja_svs_slaser.get_csde">[docs]</a>    <span class="k">def</span> <span class="nf">get_csde</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">voxel_size_mm_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate chemical shift displacement in three directions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        csd : numpy array of floats</span>
<span class="sd">            Estimated CS displacement in %/ppm</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># init</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;estimating chemical shift displacement error...&quot;</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">voxel_size_mm_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># TODO: I am not smart enough to make this work properly. Voxel orientation is sometimes modified meaning that RF pulses #1, #2 and #3 do not always select along RL, AP, HF or X, Y, Z. I am not very good with transformation matrix and stuff... :( So for now, I give the possibility to the user to input his voxel sizes in the order of pulsing.</span>
            <span class="n">voxel_size_mm_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">voxel_size</span>

        <span class="n">csd</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">df_abs_Hz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f0</span>  <span class="c1"># yes, 1ppm==f0[MHz]/1e6=297Hz at 7T</span>

        <span class="c1"># assuming X-Y-Z is done with 90-180-180</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;estimating CS displacement for semiLASER: assuming (90x)-(180y)-(180z)!...&quot;</span><span class="p">)</span>

        <span class="c1"># X selection done with asymmetric 90° pulse</span>
        <span class="c1"># we do not know much about this pulse. We can only say it is 3.4kHz large if the duration is 2ms</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;estimating CS displacement for (90x): this pulse is the weird asymmetric one, we have no idea what it is exactly!&quot;</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_exc_duration</span> <span class="o">==</span> <span class="mf">2000.0</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;since its duration is 2ms here, we assume, according to Oz &amp; Tkac, MRM 65:901-910 (2011), that its bandwidth is 3.4kHz.&quot;</span><span class="p">)</span>
            <span class="n">bw_x_Hz</span> <span class="o">=</span> <span class="mf">3400.0</span>
            <span class="n">grad_x_Hz_m</span> <span class="o">=</span> <span class="n">bw_x_Hz</span> <span class="o">/</span> <span class="p">(</span><span class="n">voxel_size_mm_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.001</span><span class="p">)</span>
            <span class="n">d_x_mm</span> <span class="o">=</span> <span class="mf">1000.0</span> <span class="o">*</span> <span class="n">df_abs_Hz</span> <span class="o">/</span> <span class="n">grad_x_Hz_m</span>
            <span class="n">d_x_prct</span> <span class="o">=</span> <span class="n">d_x_mm</span> <span class="o">/</span> <span class="n">voxel_size_mm_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">100.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;since its duration is not 2ms here, we do not know its bandwith. Therefore, no way to calculate the CS displacement for this axis, sorry ;)&quot;</span><span class="p">)</span>
            <span class="n">d_x_prct</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Y selection done with 180°</span>
        <span class="n">bw_y_Hz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_r</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span> <span class="o">/</span> <span class="mf">1000000.0</span><span class="p">)</span>
        <span class="n">grad_y_Hz_m</span> <span class="o">=</span> <span class="n">bw_y_Hz</span> <span class="o">/</span> <span class="p">(</span><span class="n">voxel_size_mm_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.001</span><span class="p">)</span>
        <span class="n">d_y_mm</span> <span class="o">=</span> <span class="mf">1000.0</span> <span class="o">*</span> <span class="n">df_abs_Hz</span> <span class="o">/</span> <span class="n">grad_y_Hz_m</span>
        <span class="n">d_y_prct</span> <span class="o">=</span> <span class="n">d_y_mm</span> <span class="o">/</span> <span class="n">voxel_size_mm_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">100.0</span>

        <span class="c1"># Z selection done with 180°</span>
        <span class="n">bw_z_Hz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_r</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span> <span class="o">/</span> <span class="mf">1000000.0</span><span class="p">)</span>
        <span class="n">grad_z_Hz_m</span> <span class="o">=</span> <span class="n">bw_z_Hz</span> <span class="o">/</span> <span class="p">(</span><span class="n">voxel_size_mm_list</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.001</span><span class="p">)</span>
        <span class="n">d_z_mm</span> <span class="o">=</span> <span class="mf">1000.0</span> <span class="o">*</span> <span class="n">df_abs_Hz</span> <span class="o">/</span> <span class="n">grad_z_Hz_m</span>
        <span class="n">d_z_prct</span> <span class="o">=</span> <span class="n">d_z_mm</span> <span class="o">/</span> <span class="n">voxel_size_mm_list</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mf">100.0</span>

        <span class="n">csd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d_x_prct</span><span class="p">,</span> <span class="n">d_y_prct</span><span class="p">,</span> <span class="n">d_z_prct</span><span class="p">])</span>

        <span class="k">return</span><span class="p">(</span><span class="n">csd</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_sech</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_asech</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span><span class="n">ma</span><span class="o">.</span><span class="n">acosh</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">x</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_rf_pulse_hsn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">tbw</span><span class="p">,</span> <span class="n">Tp</span><span class="p">,</span> <span class="n">trunc</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a n-order hyperbolic secant (HSn) RF pulse. This function was 100% taken from the MATLAB FID-A (Jamie Near&#39;s code) toolbox and tranlated to Python. It is based on the method of gradient modulated offset-independent adiabaticity as first described by Tannus and Garwood in NMR Biomed 1997; 10:423-434.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        N : int</span>
<span class="sd">            Number of points in RF waveform</span>
<span class="sd">        n : int</span>
<span class="sd">            Order of the HS pulse</span>
<span class="sd">        tbw : float</span>
<span class="sd">            Time bandwidth product (Hz*s)</span>
<span class="sd">        Tp : float</span>
<span class="sd">            Duration of the RF pulse (ms)</span>
<span class="sd">        trunc : float</span>
<span class="sd">            Truncation of the amplitude modulation function</span>
<span class="sd">        display : bool</span>
<span class="sd">            Display resulting time and frequency pulse profiles</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pulse_amp  : float list</span>
<span class="sd">            RF amplitude waveform for a HSn pulse (normalized 0-1)</span>
<span class="sd">        pulse_phi  : float list</span>
<span class="sd">            RF phase waveform for a HSn pulse (deg)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make sure N is even</span>
        <span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">Tp_s</span> <span class="o">=</span> <span class="n">Tp</span> <span class="o">/</span> <span class="mf">1000.0</span>

        <span class="c1"># initialize the time vectors ta has N steps from 0 to Tp.</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Tp_s</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>

        <span class="c1"># tau has N steps from -1 to 1. (useful for defining our AM and GM functions.)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">Tp_s</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># create truncation factor.</span>
        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_asech</span><span class="p">(</span><span class="n">trunc</span><span class="p">)</span>

        <span class="c1"># Find Bandwith Factor A</span>
        <span class="n">bw</span> <span class="o">=</span> <span class="n">tbw</span> <span class="o">/</span> <span class="n">Tp_s</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">bw</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># find time step size</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># First define the AM function:</span>
        <span class="n">F1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sech</span><span class="p">(</span><span class="n">B</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">n</span><span class="p">)))</span>

        <span class="c1"># now calculate the FM function based on the assumption of a constant gradient by integrating the AM function:</span>
        <span class="n">F2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">F1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">F2</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">F1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="n">F1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">F1</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">F1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):])</span>
        <span class="n">F2</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">int</span><span class="p">(</span><span class="n">F1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">F2</span><span class="p">[</span><span class="n">F1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="nb">int</span><span class="p">(</span><span class="n">F1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">F2</span> <span class="o">=</span> <span class="n">F2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">F2</span><span class="p">)</span>

        <span class="n">pulse_amp</span> <span class="o">=</span> <span class="n">F1</span>
        <span class="n">FM</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">F2</span>

        <span class="c1"># create phase modulation function</span>
        <span class="n">pulse_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">FM</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="mf">360.0</span>

        <span class="c1"># display</span>
        <span class="k">if</span><span class="p">(</span><span class="n">display</span><span class="p">):</span>
            <span class="c1"># display</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
            <span class="n">axs</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">set_window_title</span><span class="p">(</span><span class="s2">&quot;_rf_pulse_hsn (mrs.sim.mrs_seq_eja_svs_slaser)&quot;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;HSn pulse generation | </span><span class="si">%.2f</span><span class="s2"> ms, BW = </span><span class="si">%.2f</span><span class="s2"> Hz, TBW/R = </span><span class="si">%.2f</span><span class="s2">, n-order = </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2"> pts&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">Tp</span><span class="p">,</span> <span class="n">bw</span><span class="p">,</span> <span class="n">tbw</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>

            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="mf">1000.0</span><span class="p">,</span> <span class="n">pulse_amp</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;time (ms)&#39;</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;pulse amplitude&#39;</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="s1">&#39;on&#39;</span><span class="p">)</span>

            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="mf">1000.0</span><span class="p">,</span> <span class="n">pulse_phi</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;phase profile&#39;</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="s1">&#39;on&#39;</span><span class="p">)</span>

            <span class="c1"># frequency profile</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">d</span><span class="o">=</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            <span class="n">pulse_cmplx</span> <span class="o">=</span> <span class="n">pulse_amp</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">pulse_phi</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>
            <span class="n">pulse_freq_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">pulse_cmplx</span><span class="p">)))</span>

            <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">,</span> <span class="n">pulse_freq_abs</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;frequency (kHz)&#39;</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;frequency profile (magnitude)&#39;</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="s1">&#39;on&#39;</span><span class="p">)</span>

            <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">()</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">return</span><span class="p">(</span><span class="n">pulse_amp</span><span class="p">,</span> <span class="n">pulse_phi</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_pulses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate HSn pulse profiles for later use during simulation. This could look like a detail but the semi-LASER behaves in particular way regarding effective TE and J-coupling BECAUSE of those pulses and their long durations. Depending on TE and pulse properties, MR peak lineshapes can be severly affected.&quot;&quot;&quot;</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_real_shape_enable</span><span class="p">):</span>
            <span class="c1"># pulse bandwidth</span>
            <span class="n">pulse_bw_hz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_r</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">)</span>

            <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_npts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="c1"># number of points: critical because pulse waveforms containing many points will slow down simulation! Let&#39;s check Nyquist criteria and choose a minium number of points...</span>
                <span class="c1"># nyquist sampling</span>
                <span class="n">pulse_min_fs</span> <span class="o">=</span> <span class="n">pulse_bw_hz</span> <span class="o">*</span> <span class="mf">2.0</span>
                <span class="n">pulse_n</span> <span class="o">=</span> <span class="n">pulse_min_fs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span> <span class="o">/</span> <span class="mf">1000.0</span>
                <span class="c1"># multiply this by 2 (empiric finding)</span>
                <span class="n">pulse_n</span> <span class="o">=</span> <span class="n">pulse_n</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pulse_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_npts</span>

            <span class="c1"># call HSn generation</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;generating a </span><span class="si">%.1f</span><span class="s2">-ms HS</span><span class="si">%d</span><span class="s2"> pulse: R=</span><span class="si">%.0f</span><span class="s2"> (BW=</span><span class="si">%.1f</span><span class="s2">kHz) using </span><span class="si">%d</span><span class="s2"> points...&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_r</span><span class="p">,</span> <span class="n">pulse_bw_hz</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">,</span> <span class="n">pulse_n</span><span class="p">))</span>
            <span class="n">pulse_amp</span><span class="p">,</span> <span class="n">pulse_phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rf_pulse_hsn</span><span class="p">(</span><span class="n">pulse_n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span><span class="p">)</span>

            <span class="c1"># store</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pulses_rfc_shape_amp_norm</span> <span class="o">=</span> <span class="n">pulse_amp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pulses_rfc_shape_phi_deg</span> <span class="o">=</span> <span class="n">pulse_phi</span>

            <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_enable</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pulse_rfc_w1max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_rfc_pulse_w1max_by_optim</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pulse_rfc_w1max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_rfc_pulse_w1max_using_ref_pulse_voltage</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;not using real shaped pulses so nothing to do here!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_rfc_pulse_w1max_using_ref_pulse_voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the RF power (w1max) of the HSn pulses using the reference voltage.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        w1_rfc_pulse_hz  : float</span>
<span class="sd">            RF power or w1 max for HSn pulse (Hz)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># optimize RF power</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;setting HSn pulse RF power using reference voltage...&quot;</span><span class="p">)</span>

        <span class="c1"># pulse area</span>
        <span class="n">pulse_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulses_rfc_shape_amp_norm</span><span class="p">))</span>
        <span class="n">pulse_rfc_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulses_rfc_shape_amp_norm</span><span class="p">,</span> <span class="n">pulse_t</span><span class="p">,</span> <span class="n">pulse_t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># find real RF power that was used</span>
        <span class="n">w1_ref_pulse_degs</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">/</span> <span class="p">(</span><span class="mi">360</span> <span class="o">*</span> <span class="mf">1e-3</span><span class="p">)</span>  <span class="c1"># deg/s</span>
        <span class="n">w1_rfc_pulse_degs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_voltage</span> <span class="o">*</span> <span class="n">w1_ref_pulse_degs</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">vref</span>  <span class="c1"># deg/s</span>
        <span class="n">w1_rfc_pulse_hz</span> <span class="o">=</span> <span class="n">w1_rfc_pulse_degs</span> <span class="o">/</span> <span class="p">(</span><span class="mf">360.0</span> <span class="o">*</span> <span class="n">pulse_rfc_area</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;HSn pulse voltage is set to </span><span class="si">%.2f</span><span class="s2">V&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_voltage</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;HSn pulse flip angle is set to </span><span class="si">%.2f</span><span class="s2">deg&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_flipangle</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;reference voltage is </span><span class="si">%.2f</span><span class="s2">V&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">vref</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;this means the HSn pulse w1max is </span><span class="si">%.2f</span><span class="s2">Hz&quot;</span> <span class="o">%</span> <span class="n">w1_rfc_pulse_hz</span><span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="n">w1_rfc_pulse_hz</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_rfc_pulse_w1max_by_optim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimize the RF power (w1max) of the HSn pulses. The current power used during acquisition, if available, will be displayed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        w1_rfc_pulse_hz_optim : float</span>
<span class="sd">            RF power or w1 max for HSn pulse (Hz)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># optimize RF power</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;optimizing RF power...&quot;</span><span class="p">)</span>

        <span class="c1"># pulse area</span>
        <span class="n">pulse_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulses_rfc_shape_amp_norm</span><span class="p">))</span>
        <span class="n">pulse_rfc_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulses_rfc_shape_amp_norm</span><span class="p">,</span> <span class="n">pulse_t</span><span class="p">,</span> <span class="n">pulse_t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># find real RF power that was used</span>
        <span class="n">w1_ref_pulse_degs</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">/</span> <span class="p">(</span><span class="mi">360</span> <span class="o">*</span> <span class="mf">1e-3</span><span class="p">)</span>  <span class="c1"># deg/s</span>
        <span class="n">w1_rfc_pulse_degs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_voltage</span> <span class="o">*</span> <span class="n">w1_ref_pulse_degs</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">vref</span>  <span class="c1"># deg/s</span>
        <span class="n">w1_rfc_pulse_hz</span> <span class="o">=</span> <span class="n">w1_rfc_pulse_degs</span> <span class="o">/</span> <span class="p">(</span><span class="mf">360.0</span> <span class="o">*</span> <span class="n">pulse_rfc_area</span><span class="p">)</span>

        <span class="c1"># prepare RF power triple axis</span>
        <span class="n">w1_range_V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_voltage_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_voltage_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_voltage_n</span><span class="p">)</span>
        <span class="n">w1_range_Hz</span> <span class="o">=</span> <span class="p">(</span><span class="n">w1_range_V</span> <span class="o">*</span> <span class="n">w1_ref_pulse_degs</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">vref</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">360.0</span> <span class="o">*</span> <span class="n">pulse_rfc_area</span><span class="p">)</span>

        <span class="c1"># in uT?</span>
        <span class="c1"># gamma = GAMMA_DICT[self.nuclei]</span>
        <span class="c1"># w1_range_uT = w1_range_Hz / gamma</span>

        <span class="c1"># run RF adjustment</span>
        <span class="n">meta_bs_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_bs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">acquired_signals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">peak_max_ppm_index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">peak_intensity_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_metabolites</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">w1_range_Hz</span><span class="p">)])</span>
        <span class="n">peak_intensity_real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_metabolites</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">w1_range_Hz</span><span class="p">)])</span>

        <span class="c1"># for each RF power (w1)</span>
        <span class="k">for</span> <span class="n">kw</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">w1_range_Hz</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pulse_rfc_w1max</span> <span class="o">=</span> <span class="n">w</span>
            <span class="c1"># for each metabolite</span>
            <span class="k">for</span> <span class="n">km</span><span class="p">,</span> <span class="n">im</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_metabolites</span><span class="p">):</span>
                <span class="n">meta_key</span> <span class="o">=</span> <span class="n">meta_bs_keys</span><span class="p">[</span><span class="n">im</span><span class="p">]</span>
                <span class="n">meta_dict_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_bs</span><span class="p">[</span><span class="n">meta_key</span><span class="p">][</span><span class="s2">&quot;metabolites&quot;</span><span class="p">][</span><span class="n">meta_key</span><span class="p">]</span>
                <span class="c1"># acquire</span>
                <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_sequence</span><span class="p">(</span><span class="n">meta_dict_entry</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">correct_apodization_nd</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span>  <span class="c1"># silent apodization</span>
                <span class="n">acquired_signals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="c1"># analyze</span>
                <span class="n">sf</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">spectrum</span><span class="p">()</span>
                <span class="k">if</span><span class="p">(</span><span class="n">kw</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="c1"># first power, let&#39;s peak pick</span>
                    <span class="n">peak_max_ppm_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sf</span><span class="p">)))</span>
                <span class="c1"># store peak intensities</span>
                <span class="n">peak_intensity_abs</span><span class="p">[</span><span class="n">km</span><span class="p">,</span> <span class="n">kw</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sf</span><span class="p">[</span><span class="n">peak_max_ppm_index</span><span class="p">[</span><span class="n">km</span><span class="p">]])</span>
                <span class="n">peak_intensity_real</span><span class="p">[</span><span class="n">km</span><span class="p">,</span> <span class="n">kw</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">sf</span><span class="p">[</span><span class="n">peak_max_ppm_index</span><span class="p">[</span><span class="n">km</span><span class="p">]])</span>

        <span class="c1"># find optimal power</span>
        <span class="c1"># first, find plateau value by taking</span>
        <span class="n">i_power</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_voltage_n</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_voltage_n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_margins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">)</span>
        <span class="n">plateau_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">peak_intensity_abs</span><span class="p">[:,</span> <span class="n">i_power</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_metabolites</span><span class="p">),</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">peak_intensity_abs_rel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">peak_intensity_abs</span> <span class="o">-</span> <span class="n">plateau_power</span><span class="p">)</span> <span class="o">/</span> <span class="n">plateau_power</span> <span class="o">*</span> <span class="mf">100.0</span>
        <span class="n">peak_intensity_abs_rel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">peak_intensity_abs_rel</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># second, find power for which variation is above 10%</span>
        <span class="n">peak_intensity_abs_rel_above_threshold_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">peak_intensity_abs_rel</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_margins</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">w1_range_Hz_optim</span> <span class="o">=</span> <span class="n">w1_range_Hz</span><span class="p">[</span><span class="n">peak_intensity_abs_rel_above_threshold_mask</span><span class="p">]</span>
        <span class="n">w1_range_Hz_optim</span> <span class="o">=</span> <span class="n">w1_range_Hz_optim</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># third, increase optimal power of 10% for security (to be sure to be in adiabatic regime)</span>
        <span class="n">w1_range_Hz_optim</span> <span class="o">=</span> <span class="n">w1_range_Hz_optim</span> <span class="o">*</span> <span class="p">(</span><span class="mi">100</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_margins</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mf">100.0</span>

        <span class="c1"># convert back to voltage (usefull for virtual pulse calibration)</span>
        <span class="n">w1_range_degs_optim</span> <span class="o">=</span> <span class="n">w1_range_Hz_optim</span> <span class="o">*</span> <span class="mf">360.0</span> <span class="o">*</span> <span class="n">pulse_rfc_area</span>  <span class="c1"># deg/s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_voltage</span> <span class="o">=</span> <span class="n">w1_range_degs_optim</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vref</span> <span class="o">/</span> <span class="n">w1_ref_pulse_degs</span>  <span class="c1"># V</span>

        <span class="c1"># what would that be in deg?</span>
        <span class="c1"># flip angles are linear with voltages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_flipangle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_flipangle</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_voltage</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_voltage</span>

        <span class="c1"># peak ppm</span>
        <span class="n">ppm</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">frequency_axis_ppm</span><span class="p">()</span>
        <span class="n">peak_max_ppm_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peak_max_ppm_index</span><span class="p">)</span>
        <span class="n">peak_max_ppm</span> <span class="o">=</span> <span class="n">ppm</span><span class="p">[</span><span class="n">peak_max_ppm_index</span><span class="p">]</span>

        <span class="c1"># display</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="n">axs</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">set_window_title</span><span class="p">(</span><span class="s2">&quot;_get_rfc_pulse_w1max_by_optim (mrs.sim.mrs_seq_eja_svs_slaser)&quot;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;RF power optimization results for sLASER&quot;</span><span class="p">)</span>

        <span class="n">afactor</span> <span class="o">=</span> <span class="p">(</span><span class="n">w1_range_Hz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">w1_range_Hz</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">peak_intensity_abs</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># for each RF power (w1)</span>
        <span class="k">for</span> <span class="n">kw</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">w1_range_Hz</span><span class="p">):</span>
            <span class="c1"># for each metabolite</span>
            <span class="k">for</span> <span class="n">km</span><span class="p">,</span> <span class="n">im</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_metabolites</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">acquired_signals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">frequency_axis_ppm</span><span class="p">(),</span> <span class="n">w</span> <span class="o">+</span> <span class="n">afactor</span> <span class="o">*</span> <span class="n">s</span><span class="o">.</span><span class="n">spectrum</span><span class="p">()</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># for each metabolite, draw ppm measurement line</span>
        <span class="k">for</span> <span class="n">km</span><span class="p">,</span> <span class="n">im</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_metabolites</span><span class="p">):</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">peak_max_ppm</span><span class="p">[</span><span class="n">km</span><span class="p">],</span> <span class="n">peak_max_ppm</span><span class="p">[</span><span class="n">km</span><span class="p">]],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">w1_range_Hz</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">w1_range_Hz</span><span class="p">)],</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;chemical shift (ppm)&#39;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;w1 (Hz)&#39;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="s1">&#39;on&#39;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># for metabolite</span>
        <span class="k">for</span> <span class="n">km</span><span class="p">,</span> <span class="n">im</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_metabolites</span><span class="p">):</span>
            <span class="n">meta_key</span> <span class="o">=</span> <span class="n">meta_bs_keys</span><span class="p">[</span><span class="n">im</span><span class="p">]</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">peak_intensity_abs</span><span class="p">[</span><span class="n">km</span><span class="p">,</span> <span class="p">:],</span> <span class="n">w1_range_Hz</span><span class="p">,</span> <span class="s1">&#39;o-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">meta_key</span> <span class="o">+</span> <span class="s2">&quot; peak intensity at </span><span class="si">%.2f</span><span class="s2">ppm (magnitude)&quot;</span> <span class="o">%</span> <span class="n">peak_max_ppm</span><span class="p">[</span><span class="n">km</span><span class="p">])</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">peak_intensity_real</span><span class="p">[</span><span class="n">km</span><span class="p">,</span> <span class="p">:],</span> <span class="n">w1_range_Hz</span><span class="p">,</span> <span class="s1">&#39;o-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">meta_key</span> <span class="o">+</span> <span class="s2">&quot; peak intensity at </span><span class="si">%.2f</span><span class="s2">ppm (real)&quot;</span> <span class="o">%</span> <span class="n">peak_max_ppm</span><span class="p">[</span><span class="n">km</span><span class="p">])</span>

        <span class="c1"># add real RF power as a line</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">peak_intensity_real</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">peak_intensity_abs</span><span class="p">)],</span> <span class="p">[</span><span class="n">w1_rfc_pulse_hz</span><span class="p">,</span> <span class="n">w1_rfc_pulse_hz</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Current RF power&quot;</span><span class="p">)</span>

        <span class="c1"># add optimal RF power as a line</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">peak_intensity_real</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">peak_intensity_abs</span><span class="p">)],</span> <span class="p">[</span><span class="n">w1_range_Hz_optim</span><span class="p">,</span> <span class="n">w1_range_Hz_optim</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Optimal RF power&quot;</span><span class="p">)</span>

        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;peak intensity&#39;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;w1 (Hz)&#39;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="s1">&#39;on&#39;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper center&#39;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">w1_range_Hz</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">w1_range_Hz</span><span class="p">))</span>

        <span class="c1"># dealing with axes Hz/V</span>
        <span class="n">ax2</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Pulse voltage (V)&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">w1_range_V</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">w1_range_V</span><span class="p">))</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;HSn pulse voltage is set to </span><span class="si">%.2f</span><span class="s2">V&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_voltage</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;HSn pulse flip angle is set to </span><span class="si">%.2f</span><span class="s2">deg&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_flipangle</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;reference voltage is </span><span class="si">%.2f</span><span class="s2">V&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">vref</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;which is equivalent to a w1max of </span><span class="si">%.2f</span><span class="s2">Hz&quot;</span> <span class="o">%</span> <span class="n">w1_rfc_pulse_hz</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;the optimization process gave however something different...&quot;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;the optimal w1max found is </span><span class="si">%.2f</span><span class="s2">Hz&quot;</span> <span class="o">%</span> <span class="n">w1_range_Hz_optim</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;which corresponds to a voltage of </span><span class="si">%.2f</span><span class="s2">V&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_voltage</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;or a flip angle of </span><span class="si">%.2f</span><span class="s2">deg&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_optim_power_flipangle</span><span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="n">w1_range_Hz_optim</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_run_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metabolite</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the NMR signal acquired using a sLASER sequence using the GAMMA library via the pyGAMMA python wrapper for one metabolite (=one spin system).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        metabolite : dict</span>
<span class="sd">            metabolite_basis_set entry for one single metabolite</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        s_MRSData2 : MRSData2 object</span>
<span class="sd">            Containing the MRS signal simulated for this metabolite</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;acquiring sLASER sequence: (90)-(180)-(180)-(180)-(180)...&quot;</span><span class="p">)</span>

        <span class="c1"># create spin system</span>
        <span class="n">sys</span><span class="p">,</span> <span class="n">amp_factor_spins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_spin_system</span><span class="p">(</span><span class="n">metabolite</span><span class="p">)</span>

        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_real_shape_enable</span><span class="p">):</span>
            <span class="c1"># convert pulse amplitude currently normalized (0-1) to Hz (compatible with GAMMA)</span>
            <span class="n">pulse_rfc_amp_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulses_rfc_shape_amp_norm</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pulse_rfc_w1max</span>
            <span class="n">pulse_rfc_phi_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulses_rfc_shape_phi_deg</span>

            <span class="c1"># prepare pyGAMMA RF pulse vectors (from Vespa)</span>
            <span class="n">pg_pulse_step_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1000.0</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">pulse_rfc_amp_np</span><span class="p">))</span>
            <span class="n">pg_pulse_rfc</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">row_vector</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pulse_rfc_amp_np</span><span class="p">))</span>
            <span class="n">pg_pulse_rfc_time</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">row_vector</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pulse_rfc_amp_np</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">pulse_rfc_amp_np</span><span class="p">,</span> <span class="n">pulse_rfc_phi_np</span><span class="p">)):</span>
                <span class="n">pg_pulse_rfc</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">pg</span><span class="o">.</span><span class="n">complex</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">pg_pulse_rfc_time</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">pg</span><span class="o">.</span><span class="n">complex</span><span class="p">(</span><span class="n">pg_pulse_step_s</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">j</span><span class="p">)</span>

            <span class="c1"># create the pulse waveform and composite pulse objects  (from Vespa)</span>
            <span class="n">pwf_hsn</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">PulWaveform</span><span class="p">(</span><span class="n">pg_pulse_rfc</span><span class="p">,</span> <span class="n">pg_pulse_rfc_time</span><span class="p">,</span> <span class="s2">&quot;HSn LASER pulse&quot;</span><span class="p">)</span>
            <span class="n">pulc180</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">PulComposite</span><span class="p">(</span><span class="n">pwf_hsn</span><span class="p">,</span> <span class="n">sys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuclei</span><span class="p">)</span>
            <span class="n">Upulc180</span> <span class="o">=</span> <span class="n">pulc180</span><span class="o">.</span><span class="n">GetUsum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># amplitude normalization</span>
        <span class="n">afactor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaling_factor</span> <span class="o">/</span> <span class="n">sys</span><span class="o">.</span><span class="n">HS</span><span class="p">()</span>

        <span class="c1"># coupling</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">Hcs</span><span class="p">(</span><span class="n">sys</span><span class="p">)</span> <span class="o">+</span> <span class="n">pg</span><span class="o">.</span><span class="n">HJ</span><span class="p">(</span><span class="n">sys</span><span class="p">)</span>

        <span class="c1"># detection stuff</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">Fm</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuclei</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span>

        <span class="c1"># timing implementation close to what the CMRR&#39;s sLASER is doing</span>
        <span class="c1"># those delays are between pulses&#39; centers</span>
        <span class="c1"># 90-a-180-b-c-180-d-e-180-f-g-180-h-FID</span>
        <span class="c1"># all in ms</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_exc_duration</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">spoiler_duration</span> <span class="o">+</span> <span class="mf">0.4e-3</span>  <span class="c1"># timing found experimentally on the 7T</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">spoiler_duration</span>  <span class="c1"># SE timing</span>
        <span class="n">de</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">spoiler_duration</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">spoiler_duration</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span> <span class="o">/</span> <span class="mf">2.0</span>  <span class="c1"># assuming shortest</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">spoiler_duration</span>
        <span class="n">gh_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spoiler_duration</span> <span class="o">+</span> <span class="mf">0.0</span>  <span class="c1"># according to measurements, TE padding happens on the last SE timing</span>
        <span class="c1"># let&#39;s calculate min TE to find TE filling value</span>
        <span class="n">te_min</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">bc</span> <span class="o">+</span> <span class="n">de</span> <span class="o">+</span> <span class="n">f</span> <span class="o">+</span> <span class="n">gh_min</span>
        <span class="n">te_fill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">te</span> <span class="o">-</span> <span class="n">te_min</span>
        <span class="c1"># check for impossible TE</span>
        <span class="k">if</span><span class="p">(</span><span class="n">te_fill</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;your echo time is too short!&quot;</span><span class="p">)</span>
        <span class="n">gh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spoiler_duration</span> <span class="o">+</span> <span class="n">te_fill</span>
        <span class="c1"># final SE timing</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">gh</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">gh</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">fg</span> <span class="o">=</span> <span class="n">f</span> <span class="o">+</span> <span class="n">g</span>

        <span class="c1"># final delay list: center to center of pulses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subdelay_c2c_ms_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">fg</span><span class="p">,</span> <span class="n">h</span><span class="p">])</span>

        <span class="c1"># now, calculate evolution delays knowing the c2c delays and the user parameters</span>
        <span class="c1"># 4 cases possible</span>
        <span class="c1"># those delays are the actual time when spins will evolve</span>
        <span class="c1"># 90-a-180-b-c-180-d-e-180-f-g-180-h-FID</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_real_shape_enable</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_evolution_during_hard_pulses</span><span class="p">):</span>
            <span class="c1"># we are using real shaped rfc pulses and a hard exc pulse</span>
            <span class="c1"># we want to keep time evolution during hard pulsing</span>
            <span class="c1"># evolution already happens during shaped pulses</span>
            <span class="n">a</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">bc</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span>
            <span class="n">de</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span>
            <span class="n">fg</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span>
            <span class="n">h</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">elif</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_real_shape_enable</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_evolution_during_hard_pulses</span><span class="p">):</span>
            <span class="c1"># we are using real shaped rfc pulses and a hard exc pulse</span>
            <span class="c1"># we do not want to keep time evolution during hard pulsing</span>
            <span class="c1"># evolution already happens during shaped pulses</span>
            <span class="n">a</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_exc_duration</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">bc</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span>
            <span class="n">de</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span>
            <span class="n">fg</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span>
            <span class="n">h</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">elif</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_real_shape_enable</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_evolution_during_hard_pulses</span><span class="p">):</span>
            <span class="c1"># we are not using real shaped rfc pulses, only a hard exc and rfc pulses</span>
            <span class="c1"># we want to keep time evolution during hard pulsing</span>
            <span class="k">pass</span>
        <span class="k">elif</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_real_shape_enable</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_evolution_during_hard_pulses</span><span class="p">):</span>
            <span class="c1"># we are not using real shaped rfc pulses, only a hard exc and rfc pulses</span>
            <span class="c1"># we do not want to keep time evolution during hard pulsing</span>
            <span class="n">a</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_exc_duration</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">bc</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span>
            <span class="n">de</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span>
            <span class="n">fg</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span>
            <span class="n">h</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="c1"># final delay list: evolution delays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subdelay_evol_ms_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">de</span><span class="p">,</span> <span class="n">fg</span><span class="p">,</span> <span class="n">h</span><span class="p">])</span>

        <span class="c1"># final tcp delay list (for CP effects)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tcp_ms_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subdelay_c2c_ms_list</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># run the sequence</span>
        <span class="n">sigma0</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">sigma_eq</span><span class="p">(</span><span class="n">sys</span><span class="p">)</span>
        <span class="n">evol_delays_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subdelay_evol_ms_list</span> <span class="o">/</span> <span class="mf">1000.0</span>  <span class="c1"># seconds</span>
        <span class="n">te_real_ms</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># excitation: hard 90 pulse to simulate asymmetric sinc pulse</span>
        <span class="n">sigma1</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">Iypuls</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">sigma0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuclei</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_evolution_during_hard_pulses</span><span class="p">):</span>
            <span class="n">te_real_ms</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_exc_duration</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># evolution</span>
        <span class="n">sigma0</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">pg</span><span class="o">.</span><span class="n">prop</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">evol_delays_s</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">te_real_ms</span> <span class="o">+=</span> <span class="n">evol_delays_s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1000.0</span>

        <span class="c1"># LASER: 2 x (pair of 180 HSn pulses)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">evol_delays_s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_real_shape_enable</span><span class="p">):</span>
                <span class="n">sigma1</span> <span class="o">=</span> <span class="n">Upulc180</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">sigma0</span><span class="p">)</span>
                <span class="n">te_real_ms</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sigma1</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">Iypuls</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">sigma0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuclei</span><span class="p">,</span> <span class="mf">180.0</span><span class="p">)</span>
                <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_evolution_during_hard_pulses</span><span class="p">):</span>
                    <span class="n">te_real_ms</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_rfc_duration</span>

            <span class="c1"># evolution</span>
            <span class="n">sigma0</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">pg</span><span class="o">.</span><span class="n">prop</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
            <span class="n">te_real_ms</span> <span class="o">+=</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">1000.0</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">FID</span><span class="p">(</span><span class="n">sigma0</span><span class="p">,</span> <span class="n">pg</span><span class="o">.</span><span class="n">gen_op</span><span class="p">(</span><span class="n">D</span><span class="p">),</span> <span class="n">H</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">)</span>  <span class="c1"># acquisition</span>

        <span class="c1"># extract complex time data points</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">,</span> <span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npts</span><span class="p">):</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">afactor</span> <span class="o">*</span> <span class="n">amp_factor_spins</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">getRe</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">getIm</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="c1"># convert to suspect</span>
        <span class="n">s_MRSData</span> <span class="o">=</span> <span class="n">suspect</span><span class="o">.</span><span class="n">MRSData</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f0</span><span class="p">)</span>
        <span class="n">s_MRSData2</span> <span class="o">=</span> <span class="n">s_MRSData</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">reco</span><span class="o">.</span><span class="n">MRSData2</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;done. (real TE=</span><span class="si">%.2f</span><span class="s2">ms)&quot;</span> <span class="o">%</span> <span class="n">te_real_ms</span><span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="n">s_MRSData2</span><span class="p">)</span></div>


<div class="viewcode-block" id="mrs_seq_eja_svs_press"><a class="viewcode-back" href="../../mrs.html#mrs.sim.mrs_seq_eja_svs_press">[docs]</a><span class="k">class</span> <span class="nc">mrs_seq_eja_svs_press</span><span class="p">(</span><span class="n">mrs_seq_press</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that represents the PRESS sequence from CMRR.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="o">=</span><span class="mf">3500.0</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">ds</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">nuclei</span><span class="o">=</span><span class="s2">&quot;1H&quot;</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="mi">4096</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">voxel_size</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="mf">5000.0</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="mf">297.2062580</span><span class="p">,</span> <span class="n">vref</span><span class="o">=</span><span class="mf">250.0</span><span class="p">,</span> <span class="n">shims</span><span class="o">=</span><span class="p">[],</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">gating_mode</span><span class="o">=</span><span class="n">gating_signal_source</span><span class="o">.</span><span class="n">NO_GATING</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">te1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">te2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a virtual STEAM sequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        te : float</span>
<span class="sd">            Echo time (ms)</span>
<span class="sd">        tr : float</span>
<span class="sd">            Repetition time (ms)</span>
<span class="sd">        na : int</span>
<span class="sd">            Number of averages/excitations</span>
<span class="sd">        ds : int</span>
<span class="sd">            Number of summy scans</span>
<span class="sd">        nuclei : string</span>
<span class="sd">            Observed nuclei. Examples: &quot;1H&quot;, &quot;31P&quot;, etc.</span>
<span class="sd">        npts : int</span>
<span class="sd">            Number of acquisition points</span>
<span class="sd">        voxel_size : list</span>
<span class="sd">            Dimensions of voxel (mm)</span>
<span class="sd">        fs : float</span>
<span class="sd">            Acquisition bandwidth (Hz)</span>
<span class="sd">        f0 : float</span>
<span class="sd">            Water Larmor frequency (MHz)</span>
<span class="sd">        vref : float</span>
<span class="sd">            Reference voltage (V)</span>
<span class="sd">        shims : list of floats</span>
<span class="sd">            List of shim voltages in volts</span>
<span class="sd">        timestamp : float</span>
<span class="sd">            Timestamp in ms</span>
<span class="sd">        gating_mode : gating_signal_source</span>
<span class="sd">            Acquisition triggering mode</span>
<span class="sd">        eff_acquisition_time : float</span>
<span class="sd">            Effective acquisition time (s)</span>
<span class="sd">        scaling_factor : float</span>
<span class="sd">            Scaling FID intensity factor</span>
<span class="sd">        te1 : float</span>
<span class="sd">            First part of TE (ms)</span>
<span class="sd">        te2 : float</span>
<span class="sd">            Second part of TE (ms)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">nuclei</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">voxel_size</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">vref</span><span class="p">,</span> <span class="n">shims</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">gating_mode</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="p">,</span> <span class="n">te1</span><span class="p">,</span> <span class="n">te2</span><span class="p">)</span>
        <span class="c1"># name of sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;eja_svs_press&quot;</span></div>


<div class="viewcode-block" id="mrs_seq_eja_svs_steam"><a class="viewcode-back" href="../../mrs.html#mrs.sim.mrs_seq_eja_svs_steam">[docs]</a><span class="k">class</span> <span class="nc">mrs_seq_eja_svs_steam</span><span class="p">(</span><span class="n">mrs_seq_steam</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that represents the STEAM sequence from CMRR.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="o">=</span><span class="mf">3500.0</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">ds</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">nuclei</span><span class="o">=</span><span class="s2">&quot;1H&quot;</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="mi">4096</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">voxel_size</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="mf">5000.0</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="mf">297.2062580</span><span class="p">,</span> <span class="n">vref</span><span class="o">=</span><span class="mf">250.0</span><span class="p">,</span> <span class="n">shims</span><span class="o">=</span><span class="p">[],</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">gating_mode</span><span class="o">=</span><span class="n">gating_signal_source</span><span class="o">.</span><span class="n">NO_GATING</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">tm</span><span class="o">=</span><span class="mf">20.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a virtual STEAM sequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        te : float</span>
<span class="sd">            Echo time (ms)</span>
<span class="sd">        tr : float</span>
<span class="sd">            Repetition time (ms)</span>
<span class="sd">        na : int</span>
<span class="sd">            Number of averages/excitations</span>
<span class="sd">        ds : int</span>
<span class="sd">            Number of summy scans</span>
<span class="sd">        nuclei : string</span>
<span class="sd">            Observed nuclei. Examples: &quot;1H&quot;, &quot;31P&quot;, etc.</span>
<span class="sd">        npts : int</span>
<span class="sd">            Number of acquisition points</span>
<span class="sd">        voxel_size : list</span>
<span class="sd">            Dimensions of voxel (mm)</span>
<span class="sd">        fs : float</span>
<span class="sd">            Acquisition bandwidth (Hz)</span>
<span class="sd">        f0 : float</span>
<span class="sd">            Water Larmor frequency (MHz)</span>
<span class="sd">        vref : float</span>
<span class="sd">            Reference voltage (V)</span>
<span class="sd">        shims : list of floats</span>
<span class="sd">            List of shim voltages in volts</span>
<span class="sd">        timestamp : float</span>
<span class="sd">            Timestamp in ms</span>
<span class="sd">        gating_mode : gating_signal_source</span>
<span class="sd">            Acquisition triggering mode</span>
<span class="sd">        eff_acquisition_time : float</span>
<span class="sd">            Effective acquisition time (s)</span>
<span class="sd">        scaling_factor : float</span>
<span class="sd">            Scaling FID intensity factor</span>
<span class="sd">        tm : float</span>
<span class="sd">            Mixing time (ms)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">nuclei</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">voxel_size</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">vref</span><span class="p">,</span> <span class="n">shims</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">gating_mode</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="p">,</span> <span class="n">tm</span><span class="p">)</span>
        <span class="c1"># name of sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;eja_svs_steam&quot;</span></div>


<div class="viewcode-block" id="mrs_seq_fid"><a class="viewcode-back" href="../../mrs.html#mrs.sim.mrs_seq_fid">[docs]</a><span class="k">class</span> <span class="nc">mrs_seq_fid</span><span class="p">(</span><span class="n">mrs_sequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that represents the pulse-acquire sequence (fid), which is actually a clone of the super class.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="o">=</span><span class="mf">3500.0</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">ds</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">nuclei</span><span class="o">=</span><span class="s2">&quot;1H&quot;</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="mi">4096</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">voxel_size</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="mf">5000.0</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="mf">297.2062580</span><span class="p">,</span> <span class="n">vref</span><span class="o">=</span><span class="mf">250.0</span><span class="p">,</span> <span class="n">shims</span><span class="o">=</span><span class="p">[],</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">gating_mode</span><span class="o">=</span><span class="n">gating_signal_source</span><span class="o">.</span><span class="n">NO_GATING</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a virtual FID sequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        te : float</span>
<span class="sd">            Echo time (ms)</span>
<span class="sd">        tr : float</span>
<span class="sd">            Repetition time (ms)</span>
<span class="sd">        na : int</span>
<span class="sd">            Number of averages/excitations</span>
<span class="sd">        ds : int</span>
<span class="sd">            Number of summy scans</span>
<span class="sd">        nuclei : string</span>
<span class="sd">            Observed nuclei. Examples: &quot;1H&quot;, &quot;31P&quot;, etc.</span>
<span class="sd">        npts : int</span>
<span class="sd">            Number of acquisition points</span>
<span class="sd">        voxel_size : list</span>
<span class="sd">            Dimensions of voxel (mm)</span>
<span class="sd">        fs : float</span>
<span class="sd">            Acquisition bandwidth (Hz)</span>
<span class="sd">        f0 : float</span>
<span class="sd">            Water Larmor frequency (MHz)</span>
<span class="sd">        vref : float</span>
<span class="sd">            Reference voltage (V)</span>
<span class="sd">        shims : list of floats</span>
<span class="sd">            List of shim voltages in volts</span>
<span class="sd">        timestamp : float</span>
<span class="sd">            Timestamp in ms</span>
<span class="sd">        gating_mode : gating_signal_source</span>
<span class="sd">            Acquisition triggering mode</span>
<span class="sd">        eff_acquisition_time : float</span>
<span class="sd">            Effective acquisition time (s)</span>
<span class="sd">        scaling_factor : float</span>
<span class="sd">            Scaling FID intensity factor</span>
<span class="sd">        scaling_factor : float</span>
<span class="sd">            Scaling FID intensity factor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">nuclei</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">voxel_size</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">vref</span><span class="p">,</span> <span class="n">shims</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">gating_mode</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="p">)</span>
        <span class="c1"># name of sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;fid&quot;</span></div>


<div class="viewcode-block" id="mrs_seq_svs_se"><a class="viewcode-back" href="../../mrs.html#mrs.sim.mrs_seq_svs_se">[docs]</a><span class="k">class</span> <span class="nc">mrs_seq_svs_se</span><span class="p">(</span><span class="n">mrs_seq_press</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that represents the PRESS sequence from SIEMENS.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="o">=</span><span class="mf">3500.0</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">ds</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">nuclei</span><span class="o">=</span><span class="s2">&quot;1H&quot;</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="mi">4096</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">voxel_size</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="mf">5000.0</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="mf">297.2062580</span><span class="p">,</span> <span class="n">vref</span><span class="o">=</span><span class="mf">250.0</span><span class="p">,</span> <span class="n">shims</span><span class="o">=</span><span class="p">[],</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">gating_mode</span><span class="o">=</span><span class="n">gating_signal_source</span><span class="o">.</span><span class="n">NO_GATING</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">te1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">te2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a virtual STEAM sequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        te : float</span>
<span class="sd">            Echo time (ms)</span>
<span class="sd">        tr : float</span>
<span class="sd">            Repetition time (ms)</span>
<span class="sd">        na : int</span>
<span class="sd">            Number of averages/excitations</span>
<span class="sd">        ds : int</span>
<span class="sd">            Number of summy scans</span>
<span class="sd">        nuclei : string</span>
<span class="sd">            Observed nuclei. Examples: &quot;1H&quot;, &quot;31P&quot;, etc.</span>
<span class="sd">        npts : int</span>
<span class="sd">            Number of acquisition points</span>
<span class="sd">        voxel_size : list</span>
<span class="sd">            Dimensions of voxel (mm)</span>
<span class="sd">        fs : float</span>
<span class="sd">            Acquisition bandwidth (Hz)</span>
<span class="sd">        f0 : float</span>
<span class="sd">            Water Larmor frequency (MHz)</span>
<span class="sd">        vref : float</span>
<span class="sd">            Reference voltage (V)</span>
<span class="sd">        shims : list of floats</span>
<span class="sd">            List of shim voltages in volts</span>
<span class="sd">        timestamp : float</span>
<span class="sd">            Timestamp in ms</span>
<span class="sd">        gating_mode : gating_signal_source</span>
<span class="sd">            Acquisition triggering mode</span>
<span class="sd">        eff_acquisition_time : float</span>
<span class="sd">            Effective acquisition time (s)</span>
<span class="sd">        scaling_factor : float</span>
<span class="sd">            Scaling FID intensity factor</span>
<span class="sd">        te1 : float</span>
<span class="sd">            First part of TE (ms)</span>
<span class="sd">        te2 : float</span>
<span class="sd">            Second part of TE (ms)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">nuclei</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">voxel_size</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">vref</span><span class="p">,</span> <span class="n">shims</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">gating_mode</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="p">,</span> <span class="n">te1</span><span class="p">,</span> <span class="n">te2</span><span class="p">)</span>
        <span class="c1"># name of sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;svs_se&quot;</span></div>


<div class="viewcode-block" id="mrs_seq_svs_st"><a class="viewcode-back" href="../../mrs.html#mrs.sim.mrs_seq_svs_st">[docs]</a><span class="k">class</span> <span class="nc">mrs_seq_svs_st</span><span class="p">(</span><span class="n">mrs_seq_steam</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that represents the STEAM sequence from SIEMENS.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="o">=</span><span class="mf">3500.0</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">ds</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">nuclei</span><span class="o">=</span><span class="s2">&quot;1H&quot;</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="mi">4096</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">voxel_size</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="mf">5000.0</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="mf">297.2062580</span><span class="p">,</span> <span class="n">vref</span><span class="o">=</span><span class="mf">250.0</span><span class="p">,</span> <span class="n">shims</span><span class="o">=</span><span class="p">[],</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">gating_mode</span><span class="o">=</span><span class="n">gating_signal_source</span><span class="o">.</span><span class="n">NO_GATING</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">tm</span><span class="o">=</span><span class="mf">20.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a virtual STEAM sequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        te : float</span>
<span class="sd">            Echo time (ms)</span>
<span class="sd">        tr : float</span>
<span class="sd">            Repetition time (ms)</span>
<span class="sd">        na : int</span>
<span class="sd">            Number of averages/excitations</span>
<span class="sd">        ds : int</span>
<span class="sd">            Number of summy scans</span>
<span class="sd">        nuclei : string</span>
<span class="sd">            Observed nuclei. Examples: &quot;1H&quot;, &quot;31P&quot;, etc.</span>
<span class="sd">        npts : int</span>
<span class="sd">            Number of acquisition points</span>
<span class="sd">        voxel_size : list</span>
<span class="sd">            Dimensions of voxel (mm)</span>
<span class="sd">        fs : float</span>
<span class="sd">            Acquisition bandwidth (Hz)</span>
<span class="sd">        f0 : float</span>
<span class="sd">            Water Larmor frequency (MHz)</span>
<span class="sd">        vref : float</span>
<span class="sd">            Reference voltage (V)</span>
<span class="sd">        shims : list of floats</span>
<span class="sd">            List of shim voltages in volts</span>
<span class="sd">        timestamp : float</span>
<span class="sd">            Timestamp in ms</span>
<span class="sd">        gating_mode : gating_signal_source</span>
<span class="sd">            Acquisition triggering mode</span>
<span class="sd">        eff_acquisition_time : float</span>
<span class="sd">            Effective acquisition time (s)</span>
<span class="sd">        scaling_factor : float</span>
<span class="sd">            Scaling FID intensity factor</span>
<span class="sd">        tm : float</span>
<span class="sd">            Mixing time (ms)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">nuclei</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">voxel_size</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">vref</span><span class="p">,</span> <span class="n">shims</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">gating_mode</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="p">,</span> <span class="n">tm</span><span class="p">)</span>
        <span class="c1"># name of sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;svs_st&quot;</span></div>


<div class="viewcode-block" id="mrs_seq_svs_st_vapor_643"><a class="viewcode-back" href="../../mrs.html#mrs.sim.mrs_seq_svs_st_vapor_643">[docs]</a><span class="k">class</span> <span class="nc">mrs_seq_svs_st_vapor_643</span><span class="p">(</span><span class="n">mrs_seq_steam</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that represents the STEAM sequence from SIEMENS WiP 643.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="o">=</span><span class="mf">3500.0</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">ds</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">nuclei</span><span class="o">=</span><span class="s2">&quot;1H&quot;</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="mi">4096</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">voxel_size</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="mf">5000.0</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="mf">297.2062580</span><span class="p">,</span> <span class="n">vref</span><span class="o">=</span><span class="mf">250.0</span><span class="p">,</span> <span class="n">shims</span><span class="o">=</span><span class="p">[],</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">gating_mode</span><span class="o">=</span><span class="n">gating_signal_source</span><span class="o">.</span><span class="n">NO_GATING</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">tm</span><span class="o">=</span><span class="mf">20.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a virtual STEAM sequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        te : float</span>
<span class="sd">            Echo time (ms)</span>
<span class="sd">        tr : float</span>
<span class="sd">            Repetition time (ms)</span>
<span class="sd">        na : int</span>
<span class="sd">            Number of averages/excitations</span>
<span class="sd">        ds : int</span>
<span class="sd">            Number of summy scans</span>
<span class="sd">        nuclei : string</span>
<span class="sd">            Observed nuclei. Examples: &quot;1H&quot;, &quot;31P&quot;, etc.</span>
<span class="sd">        npts : int</span>
<span class="sd">            Number of acquisition points</span>
<span class="sd">        voxel_size : list</span>
<span class="sd">            Dimensions of voxel (mm)</span>
<span class="sd">        fs : float</span>
<span class="sd">            Acquisition bandwidth (Hz)</span>
<span class="sd">        f0 : float</span>
<span class="sd">            Water Larmor frequency (MHz)</span>
<span class="sd">        vref : float</span>
<span class="sd">            Reference voltage (V)</span>
<span class="sd">        shims : list of floats</span>
<span class="sd">            List of shim voltages in volts</span>
<span class="sd">        timestamp : float</span>
<span class="sd">            Timestamp in ms</span>
<span class="sd">        gating_mode : gating_signal_source</span>
<span class="sd">            Acquisition triggering mode</span>
<span class="sd">        scaling_factor : float</span>
<span class="sd">            Scaling FID intensity factor</span>
<span class="sd">        eff_acquisition_time : float</span>
<span class="sd">            Effective acquisition time (s)</span>
<span class="sd">        tm : float</span>
<span class="sd">            Mixing time (ms)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">nuclei</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">voxel_size</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">vref</span><span class="p">,</span> <span class="n">shims</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">gating_mode</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="p">,</span> <span class="n">tm</span><span class="p">)</span>
        <span class="c1"># name of sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;svs_st_vapor_643&quot;</span></div>


<div class="viewcode-block" id="mrs_seq_svs_DW_slaser_b"><a class="viewcode-back" href="../../mrs.html#mrs.sim.mrs_seq_svs_DW_slaser_b">[docs]</a><span class="k">class</span> <span class="nc">mrs_seq_svs_DW_slaser_b</span><span class="p">(</span><span class="n">mrs_seq_press</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that represents the DW semi-LASER sequence that Yasmin&#39;s wrote (temporarly based on PRESS).&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="o">=</span><span class="mf">3500.0</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">ds</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">nuclei</span><span class="o">=</span><span class="s2">&quot;1H&quot;</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="mi">4096</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">voxel_size</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="mf">5000.0</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="mf">297.2062580</span><span class="p">,</span> <span class="n">vref</span><span class="o">=</span><span class="mf">250.0</span><span class="p">,</span> <span class="n">shims</span><span class="o">=</span><span class="p">[],</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">gating_mode</span><span class="o">=</span><span class="n">gating_signal_source</span><span class="o">.</span><span class="n">NO_GATING</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">te1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">te2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">directions_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bvalues_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_b0</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a virtual STEAM sequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        te : float</span>
<span class="sd">            Echo time (ms)</span>
<span class="sd">        tr : float</span>
<span class="sd">            Repetition time (ms)</span>
<span class="sd">        na : int</span>
<span class="sd">            Number of averages/excitations</span>
<span class="sd">        ds : int</span>
<span class="sd">            Number of summy scans</span>
<span class="sd">        nuclei : string</span>
<span class="sd">            Observed nuclei. Examples: &quot;1H&quot;, &quot;31P&quot;, etc.</span>
<span class="sd">        npts : int</span>
<span class="sd">            Number of acquisition points</span>
<span class="sd">        voxel_size : list</span>
<span class="sd">            Dimensions of voxel (mm)</span>
<span class="sd">        fs : float</span>
<span class="sd">            Acquisition bandwidth (Hz)</span>
<span class="sd">        f0 : float</span>
<span class="sd">            Water Larmor frequency (MHz)</span>
<span class="sd">        vref : float</span>
<span class="sd">            Reference voltage (V)</span>
<span class="sd">        shims : list of floats</span>
<span class="sd">            List of shim voltages in volts</span>
<span class="sd">        timestamp : float</span>
<span class="sd">            Timestamp in ms</span>
<span class="sd">        gating_mode : gating_signal_source</span>
<span class="sd">            Acquisition triggering mode</span>
<span class="sd">        eff_acquisition_time : float</span>
<span class="sd">            Effective acquisition time (s)</span>
<span class="sd">        scaling_factor : float</span>
<span class="sd">            Scaling FID intensity factor</span>
<span class="sd">        te1 : float</span>
<span class="sd">            First part of TE (ms)</span>
<span class="sd">        te2 : float</span>
<span class="sd">            Second part of TE (ms)</span>
<span class="sd">        directions_list : list</span>
<span class="sd">            List of directions used for diffusion-weighting</span>
<span class="sd">        bvalues_list : list</span>
<span class="sd">            List of bvalues used for diffusion-weighting</span>
<span class="sd">        n_b0 : int</span>
<span class="sd">            Number of b0 scans</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">te</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">nuclei</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">voxel_size</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">vref</span><span class="p">,</span> <span class="n">shims</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">gating_mode</span><span class="p">,</span> <span class="n">eff_acquisition_time</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="p">,</span> <span class="n">te1</span><span class="p">,</span> <span class="n">te2</span><span class="p">)</span>
        <span class="c1"># name of sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;svs_DW_slaser_b&quot;</span>
        <span class="c1"># directions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directions</span> <span class="o">=</span> <span class="n">directions_list</span>
        <span class="c1"># bvalues</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bvalues</span> <span class="o">=</span> <span class="n">bvalues_list</span>
        <span class="c1"># number of b0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_b0</span> <span class="o">=</span> <span class="n">n_b0</span></div>


<div class="viewcode-block" id="metabolite_basis_set"><a class="viewcode-back" href="../../mrs.html#mrs.sim.metabolite_basis_set">[docs]</a><span class="k">class</span> <span class="nc">metabolite_basis_set</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The metabolite_basis_set class is a big dictionnary of metabolites with their respective chemical shift and J coupling information.&quot;&quot;&quot;</span>

    <span class="c1"># frozen stuff: a technique to prevent creating new attributes</span>
    <span class="c1"># (https://stackoverflow.com/questions/3603502/prevent-creating-new-attributes-outside-init)</span>
    <span class="n">__isfrozen</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overload of __setattr__ method to check that we are not creating a new attribute.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__isfrozen</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error_new_attribute</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basis_set_name</span><span class="o">=</span><span class="n">default_paths</span><span class="o">.</span><span class="n">DEFAULT_META_BASIS_SET_NAME</span><span class="p">,</span> <span class="n">database_xls_file</span><span class="o">=</span><span class="n">default_paths</span><span class="o">.</span><span class="n">DEFAULT_META_DB_FILE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a metabolite_basis_set object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        basis_set_name : string</span>
<span class="sd">            Metabolite basis set name corresponding the a &quot;Template_BASISSETNAME&quot; tab in the xls file</span>
<span class="sd">        database_xls_file : string</span>
<span class="sd">            Excel file containing metabolite chemical shifts, J-coupling, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">metabolite_basis_set</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># xls file that contains metabolites properties (you should not change that)</span>
        <span class="c1"># xls file that contains your metabolite basis set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis_set_name</span> <span class="o">=</span> <span class="n">basis_set_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xls_file</span> <span class="o">=</span> <span class="n">default_paths</span><span class="o">.</span><span class="n">DEFAULT_META_DB_FILE</span>

        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;initializing metabolite database...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_xls_file</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_header_file</span><span class="p">()</span>

        <span class="c1"># freeze</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__isfrozen</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__eq_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare and return equality check for nested dictionnaries d1 and d2.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        d1 : dict</span>
<span class="sd">            Dictionnary 1</span>
<span class="sd">        d2 : dict</span>
<span class="sd">            Dictionnary 2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        r : bool</span>
<span class="sd">            Self if equal to other</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check keys</span>
        <span class="k">if</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">!=</span> <span class="n">d2</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">return</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># check key values</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="c1"># check key values type</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">d1</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">==</span> <span class="nb">dict</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">d2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__eq_dict</span><span class="p">(</span><span class="n">d1</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">d2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">elif</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">d1</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">d2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">d1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">d2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">d1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">d2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

            <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">r</span><span class="p">):</span>
                <span class="k">return</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overload of &quot;equal to&quot; operator so that we can compare two metabolite basis set (usefull when looking for a adequat sequence/basis set).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        r : bool</span>
<span class="sd">            Self if equal to other</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check attributes</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">):</span>
            <span class="k">return</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># check dict content</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__eq_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_read_xls_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read the xls file specified by &quot;self._xls_file&quot; and stores all the information (chemical shifts, nuclei, J couplings).&quot;&quot;&quot;</span>
        <span class="c1"># TODO: need to work with gitable xls format, FODS!</span>
        <span class="c1"># remove annoying warning</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">)</span>

        <span class="c1"># first, read xls metabolite basis set file and parse it</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;reading metabolite basis set from XLS file...&quot;</span><span class="p">)</span>
        <span class="n">book_db</span> <span class="o">=</span> <span class="n">open_workbook</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xls_file</span><span class="p">)</span>
        <span class="c1"># get sheets from database file</span>
        <span class="n">sheet_names</span> <span class="o">=</span> <span class="n">book_db</span><span class="o">.</span><span class="n">sheet_by_name</span><span class="p">(</span><span class="s1">&#39;Metabolites&#39;</span><span class="p">)</span>
        <span class="n">sheet_ppm</span> <span class="o">=</span> <span class="n">book_db</span><span class="o">.</span><span class="n">sheet_by_name</span><span class="p">(</span><span class="s1">&#39;PPM&#39;</span><span class="p">)</span>
        <span class="n">sheet_iso</span> <span class="o">=</span> <span class="n">book_db</span><span class="o">.</span><span class="n">sheet_by_name</span><span class="p">(</span><span class="s1">&#39;Nuclei&#39;</span><span class="p">)</span>

        <span class="c1"># read basis set sheet</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_excel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xls_file</span><span class="p">,</span> <span class="n">sheet_name</span><span class="o">=</span><span class="s2">&quot;Template_&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_set_name</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;Metabolites&quot;</span><span class="p">)</span>

        <span class="c1"># browse metabolite groups in template</span>
        <span class="k">for</span> <span class="n">this_metagroup_name</span><span class="p">,</span> <span class="n">this_row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>

            <span class="k">if</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">this_row</span><span class="p">[</span><span class="s2">&quot;Consisting of&quot;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">):</span>
                <span class="c1"># solo metabolite</span>
                <span class="n">this_metaname_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">this_metagroup_name</span><span class="p">]</span>
            <span class="k">elif</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">this_row</span><span class="p">[</span><span class="s2">&quot;Consisting of&quot;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># group</span>
                <span class="n">this_metaname_list</span> <span class="o">=</span> <span class="n">this_row</span><span class="p">[</span><span class="s2">&quot;Consisting of&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>
                <span class="n">this_metaname_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">this_metaname_list</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;weird bug while reading XLS file. Sorry :P&quot;</span><span class="p">)</span>

            <span class="c1"># prepare group entry</span>
            <span class="n">this_metagroup_entry</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;metabolites&quot;</span><span class="p">:</span> <span class="p">{}}</span>

            <span class="c1"># look for the members of the group</span>
            <span class="k">for</span> <span class="n">this_meta_name</span> <span class="ow">in</span> <span class="n">this_metaname_list</span><span class="p">:</span>
                <span class="c1"># is this metagroup name is a metabolite or not ?</span>
                <span class="k">if</span><span class="p">(</span><span class="n">this_meta_name</span> <span class="ow">in</span> <span class="n">sheet_names</span><span class="o">.</span><span class="n">col_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
                    <span class="c1"># its index</span>
                    <span class="n">this_meta_ind</span> <span class="o">=</span> <span class="n">sheet_names</span><span class="o">.</span><span class="n">col_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">this_meta_name</span><span class="p">)</span>

                    <span class="c1"># find info on this meta</span>
                    <span class="c1"># ppm</span>
                    <span class="n">this_meta_ppm_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sheet_ppm</span><span class="o">.</span><span class="n">row_values</span><span class="p">(</span><span class="n">this_meta_ind</span><span class="p">))</span>
                    <span class="n">this_meta_ppm_line</span><span class="p">[</span><span class="n">this_meta_ppm_line</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">this_ppm_list</span> <span class="o">=</span> <span class="n">this_meta_ppm_line</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                    <span class="n">this_meta_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">this_ppm_list</span><span class="p">)</span>
                    <span class="n">this_ppm_list</span> <span class="o">=</span> <span class="n">this_ppm_list</span><span class="p">[</span><span class="n">this_meta_mask</span><span class="p">]</span>

                    <span class="c1"># iso</span>
                    <span class="n">this_meta_iso_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sheet_iso</span><span class="o">.</span><span class="n">row_values</span><span class="p">(</span><span class="n">this_meta_ind</span><span class="p">))</span>
                    <span class="n">this_meta_iso_line</span><span class="p">[</span><span class="n">this_meta_iso_line</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">this_iso_list</span> <span class="o">=</span> <span class="n">this_meta_iso_line</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                    <span class="n">this_iso_list</span> <span class="o">=</span> <span class="n">this_iso_list</span><span class="p">[</span><span class="n">this_meta_mask</span><span class="p">]</span>

                    <span class="c1"># J couplings</span>
                    <span class="c1"># check if there is a sheet for this metabolite</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">this_meta_name</span> <span class="ow">in</span> <span class="n">book_db</span><span class="o">.</span><span class="n">sheet_names</span><span class="p">()):</span>
                        <span class="n">this_sheet_Jcouplings</span> <span class="o">=</span> <span class="n">book_db</span><span class="o">.</span><span class="n">sheet_by_name</span><span class="p">(</span><span class="n">this_meta_name</span><span class="p">)</span>
                        <span class="n">this_j_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">this_ppm_list</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_ppm_list</span><span class="p">)],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">irowJ</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">this_ppm_list</span><span class="p">)):</span>
                            <span class="c1"># ppm</span>
                            <span class="n">this_meta_j_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">this_sheet_Jcouplings</span><span class="o">.</span><span class="n">row_values</span><span class="p">(</span><span class="n">irowJ</span><span class="p">))</span>
                            <span class="n">this_meta_j_line</span><span class="p">[</span><span class="n">this_meta_j_line</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                            <span class="n">this_meta_j_line</span> <span class="o">=</span> <span class="n">this_meta_j_line</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                            <span class="n">this_meta_j_line</span> <span class="o">=</span> <span class="n">this_meta_j_line</span><span class="p">[</span><span class="n">this_meta_mask</span><span class="p">]</span>
                            <span class="n">this_j_list</span><span class="p">[</span><span class="n">irowJ</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">this_meta_j_line</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># if no sheet, put all J-couplings to zeroes</span>
                        <span class="n">this_j_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">this_ppm_list</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_ppm_list</span><span class="p">)])</span>

                    <span class="c1"># append metabolite entry for this metabolite group</span>
                    <span class="n">this_metagroup_entry</span><span class="p">[</span><span class="s2">&quot;metabolites&quot;</span><span class="p">][</span><span class="n">this_meta_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;ppm&quot;</span><span class="p">:</span> <span class="n">this_ppm_list</span><span class="p">,</span> <span class="s2">&quot;iso&quot;</span><span class="p">:</span> <span class="n">this_iso_list</span><span class="p">,</span> <span class="s2">&quot;J&quot;</span><span class="p">:</span> <span class="n">this_j_list</span><span class="p">}</span>

            <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">this_metagroup_entry</span><span class="p">[</span><span class="s2">&quot;metabolites&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;metabolite </span><span class="si">%s</span><span class="s2"> is empty! Check your metabolite basis set in the XLS file!&quot;</span> <span class="o">%</span> <span class="n">this_metagroup_name</span><span class="p">)</span>

            <span class="c1"># add extra infos to metabolite group</span>
            <span class="c1"># is it a MM?</span>
            <span class="n">this_metagroup_entry</span><span class="p">[</span><span class="s2">&quot;Macromecule&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">this_row</span><span class="p">[</span><span class="s2">&quot;Type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Macromolecule&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">this_row</span><span class="p">[</span><span class="s2">&quot;Type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Ref. Macromolecule&quot;</span><span class="p">)</span>
            <span class="c1"># omg, is it the reference MM?</span>
            <span class="n">this_metagroup_entry</span><span class="p">[</span><span class="s2">&quot;Reference macromolecule&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">this_row</span><span class="p">[</span><span class="s2">&quot;Type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Ref. Macromolecule&quot;</span><span class="p">)</span>

            <span class="c1"># oh maybe, is it the reference metabolite?</span>
            <span class="n">this_metagroup_entry</span><span class="p">[</span><span class="s2">&quot;Reference metabolite&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">this_row</span><span class="p">[</span><span class="s2">&quot;Type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Ref. Metabolite&quot;</span><span class="p">)</span>
            <span class="c1"># min/max concentration</span>
            <span class="n">this_metagroup_entry</span><span class="p">[</span><span class="s2">&quot;Concentration min&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_row</span><span class="p">[</span><span class="s2">&quot;Concentration min (mmol/kg)&quot;</span><span class="p">]</span>
            <span class="n">this_metagroup_entry</span><span class="p">[</span><span class="s2">&quot;Concentration max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_row</span><span class="p">[</span><span class="s2">&quot;Concentration max (mmol/kg)&quot;</span><span class="p">]</span>
            <span class="c1"># T1s/T2s</span>
            <span class="n">this_metagroup_entry</span><span class="p">[</span><span class="s2">&quot;T1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_row</span><span class="p">[</span><span class="s2">&quot;T1 (ms)&quot;</span><span class="p">]</span>
            <span class="n">this_metagroup_entry</span><span class="p">[</span><span class="s2">&quot;T2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_row</span><span class="p">[</span><span class="s2">&quot;T2 (ms)&quot;</span><span class="p">]</span>
            <span class="c1"># LCModel name</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">this_row</span><span class="p">[</span><span class="s2">&quot;LCModel name&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">this_metagroup_entry</span><span class="p">[</span><span class="s2">&quot;LCModel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">this_metagroup_entry</span><span class="p">[</span><span class="s2">&quot;LCModel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_row</span><span class="p">[</span><span class="s2">&quot;LCModel name&quot;</span><span class="p">]</span>

            <span class="c1"># and add the group to the dict</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">this_metagroup_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_metagroup_entry</span>

    <span class="k">def</span> <span class="nf">_write_header_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interesting method here... It generates a python .py and writes very usefull aliases to access quickly to a specific metabolite or parameter. Since metabolite indexes depend on the metabolite database, this python header file is regenerated each time the metabolite basis set is initialized.&quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;generating metabolite and parameter aliases...&quot;</span><span class="p">)</span>

        <span class="c1"># find location of package</span>
        <span class="c1"># this file needs to be specifically in the package folder!</span>
        <span class="c1"># because we will later import it</span>
        <span class="c1"># (I know it is a bit ugly but so practical)</span>
        <span class="n">pkg_folder</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">absolute</span><span class="p">())</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pkg_folder</span> <span class="o">+</span> <span class="s2">&quot;/aliases.py&quot;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;#!/usr/bin/env python3&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;# -*- coding: utf-8 -*-</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;# This file is automatically generated on the fly by sim.py! Do not try to modify it please.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># metabolite aliases</span>
            <span class="n">metagroup_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">this_meta_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">metagroup_names</span><span class="p">):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;m_&quot;</span> <span class="o">+</span> <span class="n">this_meta_name</span> <span class="o">+</span> <span class="s2">&quot; = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># parameter aliases</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;p_cm = 0</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;p_dd = 1</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;p_df = 2</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;p_dp = 3</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># all metabolite alias</span>
            <span class="n">ind_ref_meta</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">n_meta</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;m_All_MBs = [&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">this_meta_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">metagroup_names</span><span class="p">):</span>
                <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="p">[</span><span class="n">this_meta_name</span><span class="p">][</span><span class="s2">&quot;Macromecule&quot;</span><span class="p">]):</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="p">)</span>
                    <span class="n">n_meta</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">this_meta_name</span><span class="p">][</span><span class="s2">&quot;Reference metabolite&quot;</span><span class="p">]):</span>
                    <span class="n">ind_ref_meta</span> <span class="o">=</span> <span class="n">k</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;]</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># ref metabolite alias</span>
            <span class="k">if</span><span class="p">(</span><span class="n">ind_ref_meta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;weird, could not find reference metabolite!?&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;m_Ref_MB = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ind_ref_meta</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># all MMs alias</span>
            <span class="n">ind_ref_MM</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">n_MM</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;m_All_MMs = [&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">this_meta_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">metagroup_names</span><span class="p">):</span>
                <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">this_meta_name</span><span class="p">][</span><span class="s2">&quot;Macromecule&quot;</span><span class="p">]):</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="p">)</span>
                    <span class="n">n_MM</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">this_meta_name</span><span class="p">][</span><span class="s2">&quot;Reference macromolecule&quot;</span><span class="p">]):</span>
                    <span class="n">ind_ref_MM</span> <span class="o">=</span> <span class="n">k</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;]</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># ref MM alias</span>
            <span class="k">if</span><span class="p">(</span><span class="n">ind_ref_MM</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;m_Ref_MM = None</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;m_Ref_MM = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ind_ref_MM</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;n_All = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_meta</span> <span class="o">+</span> <span class="n">n_MM</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;n_MBs = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_meta</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;n_MMs = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_MM</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="metabolite_basis_set.get_literature_min"><a class="viewcode-back" href="../../mrs.html#mrs.sim.metabolite_basis_set.get_literature_min">[docs]</a>    <span class="k">def</span> <span class="nf">get_literature_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the minimum in vivo human values found in literature, no macromolecules.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cmin : numpy array</span>
<span class="sd">            Array containing the minimum metabolite concentrations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># browse though the database and find min values from literature</span>
        <span class="n">cmin</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">this_metagroup_key</span><span class="p">,</span> <span class="n">this_metagroup_entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">cmin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_metagroup_entry</span><span class="p">[</span><span class="s2">&quot;Concentration min&quot;</span><span class="p">])</span>

        <span class="c1"># convert to np</span>
        <span class="n">cmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cmin</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">cmin</span><span class="p">)</span></div>

<div class="viewcode-block" id="metabolite_basis_set.get_literature_max"><a class="viewcode-back" href="../../mrs.html#mrs.sim.metabolite_basis_set.get_literature_max">[docs]</a>    <span class="k">def</span> <span class="nf">get_literature_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the maximum in vivo values found in literature, no macromolecules.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cmax : numpy array</span>
<span class="sd">            Array containing the maximum metabolite concentrations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># browse though the database and find min values from literature</span>
        <span class="n">cmax</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">this_metagroup_key</span><span class="p">,</span> <span class="n">this_metagroup_entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">cmax</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_metagroup_entry</span><span class="p">[</span><span class="s2">&quot;Concentration max&quot;</span><span class="p">])</span>

        <span class="c1"># convert to np</span>
        <span class="n">cmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cmax</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">cmax</span><span class="p">)</span></div>

<div class="viewcode-block" id="metabolite_basis_set.print"><a class="viewcode-back" href="../../mrs.html#mrs.sim.metabolite_basis_set.print">[docs]</a>    <span class="k">def</span> <span class="nf">print</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print the metabolite database with all the information (chemical shifts, nuclei, J couplings).&quot;&quot;&quot;</span>
        <span class="n">cell_nchar</span> <span class="o">=</span> <span class="mi">8</span>

        <span class="c1"># and now browse though the database and display everything</span>
        <span class="k">for</span> <span class="n">this_metagroup_key</span><span class="p">,</span> <span class="n">this_metagroup_entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">this_meta_key</span><span class="p">,</span> <span class="n">this_meta_entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">this_metagroup_key</span><span class="p">][</span><span class="s2">&quot;metabolites&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&gt; metabolite [&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">cprint</span><span class="p">(</span><span class="n">this_metagroup_key</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bold&#39;</span><span class="p">],</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">cprint</span><span class="p">(</span><span class="n">this_meta_key</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bold&#39;</span><span class="p">],</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)</span>

                <span class="c1"># first nuclei line</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;nuclei&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">cell_nchar</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">cell_nchar</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">this_iso</span> <span class="ow">in</span> <span class="n">this_meta_entry</span><span class="p">[</span><span class="s2">&quot;iso&quot;</span><span class="p">]:</span>
                    <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;(</span><span class="si">%2d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">this_iso</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">cell_nchar</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">()</span>

                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">cell_nchar</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;ppm&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">cell_nchar</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">this_ppm</span> <span class="ow">in</span> <span class="n">this_meta_entry</span><span class="p">[</span><span class="s2">&quot;ppm&quot;</span><span class="p">]:</span>
                    <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;</span><span class="si">%.1f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">this_ppm</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">cell_nchar</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">()</span>

                <span class="k">for</span> <span class="p">(</span><span class="n">this_iso</span><span class="p">,</span> <span class="n">this_ppm</span><span class="p">,</span> <span class="n">irowJ</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">this_meta_entry</span><span class="p">[</span><span class="s2">&quot;iso&quot;</span><span class="p">],</span> <span class="n">this_meta_entry</span><span class="p">[</span><span class="s2">&quot;ppm&quot;</span><span class="p">],</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">this_meta_entry</span><span class="p">[</span><span class="s2">&quot;ppm&quot;</span><span class="p">]))):</span>
                    <span class="c1"># recall nuclei and chemical shift for 1st and 2nd col</span>
                    <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;(</span><span class="si">%2d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">this_iso</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">cell_nchar</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;</span><span class="si">%.1f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">this_ppm</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">cell_nchar</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">icolJ</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">this_meta_entry</span><span class="p">[</span><span class="s2">&quot;J&quot;</span><span class="p">])):</span>
                        <span class="nb">print</span><span class="p">((</span><span class="s2">&quot;</span><span class="si">%.1f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">this_meta_entry</span><span class="p">[</span><span class="s2">&quot;J&quot;</span><span class="p">][</span><span class="n">irowJ</span><span class="p">][</span><span class="n">icolJ</span><span class="p">])</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">cell_nchar</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="metabolite_basis_set.to_dataframe"><a class="viewcode-back" href="../../mrs.html#mrs.sim.metabolite_basis_set.to_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">to_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_obj</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">prefix_str</span><span class="o">=</span><span class="s2">&quot;metabolite_basisset_&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the object&#39;s attributes to dataframe. Can include the object itself.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        include_obj : boolean</span>
<span class="sd">            Include self to the dataframe row</span>
<span class="sd">        prefix_str : string</span>
<span class="sd">            Prefix string to add to column names</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df : Dataframe</span>
<span class="sd">            Containing the attributes as columns (a single row)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;converting to dataframe...&quot;</span><span class="p">)</span>

        <span class="c1"># get all attributes but remove the private ones</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">([</span><span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)])</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">regex</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;^(?!_).*&quot;</span><span class="p">))</span>

        <span class="k">if</span><span class="p">(</span><span class="n">include_obj</span><span class="p">):</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;obj&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">add_prefix</span><span class="p">(</span><span class="n">prefix_str</span><span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, Tangi Roussel

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>